$  
$ #if defined(MWF77_CAPS)
$ #define MWF77_multiscale_mesher MULTISCALE_MESHER_UNIF_REFINE_CFNAME
$ #define MWF77_get_filetype GET_FILETYPE_CFNAME
$ #elif defined(MWF77_UNDERSCORE1)
$ #define MWF77_multiscale_mesher multiscale_mesher_unif_refine_cfname_ 
$ #define MWF77_get_filetype get_filetype_cfname_ 
$ #elif defined(MWF77_UNDERSCORE0)
$ #define MWF77_multiscale_mesher multiscale_mesher_unif_refine_cfname 
$ #define MWF77_get_filetype get_filetype_cfname 
$ #else
$ #define MWF77_multiscale_mesher multiscale_mesher_unif_refine_cfname__
$ #define MWF77_get_filetype get_filetype_cfname__
$ #endif
$
$ void MWF77_multiscale_mesher(char *, int*, int*, int *, int *, int *, double *, char *, int *);
$ void MWF77_get_filetype(char *, int *, int *);
$
%
%%  Surface smoother routines
%%
%
%
@ src/multiscale_mesher.m
function S = multiscale_mesher(fnamein, norder, opts)
% 
%  MULTISCALE_MESHER creates a smooth high order triangulated surface 
%    based on an input mesh file containing first/second order
%    triangles/quads. If the mesh comprises of quads, then each quad
%    is split into two triangles. 
%
%  Supported mesh formats include, .gidmsh, .tri, .msh, gmshv2, 
%  and gmshv4
%  
%  Syntax
%    S = multiscale_mesher(fnamein, norder)
%    S = multiscale_mesher(fnamein, norder, opts)
%
%  Input arguments:
%    * fnamein: input mesh file name
%    * norder: order of discretization for smooth surface
%    * opts: options struct (optional)
%        opts.nquad (12), quadrature order for computing level set
%        opts.rlam (10), smoothing parameter (should be between 2.5 and 10)
%        opts.adapt_sigma (1), adapt_sigma = 0, uses uniform sigma for mollifier
%                              adapt_sigma = 1, uses adaptive sigma
%        opts.nrefine (0), number of refinements
%        opts.filetype, type of file
%          filetype = 1, for .msh from gidmsh
%          filetype = 2, for .tri
%          filetype = 3, for .gidmsh
%          filetype = 4, for .msh gmsh v2
%          filetype = 5, for .msh gmsh v2
%                               
%      
%  
    d = dir(fnamein);
    if isempty(d)
        error('MULTISCALE_MESHER: invalid file\n');
    end
    fnameuse = fullfile(d.folder, d.name);

    if nargin < 3
        opts = [];
    end


    fnameoutuse = fullfile(d.folder, '/tmp');
    
    norder_skel = 12;
    if isfield(opts, 'nquad')
        norder_skel = opts.nquad;
    end

    norder_smooth = norder;
    nrefine = 0;
    if isfield(opts, 'nrefine')
        nrefine = opts.nrefine;
    end


    adapt_sigma = 1;
    if isfield(opts, 'adapt_sigma')
        adapt_sigma = opts.adapt_sigma;
    end
    rlam = 10;
    if isfield(opts, 'rlam')
        rlam = opts.rlam;
    end

    if isfield(opts, 'filetype')
        ifiletype = opts.filetype;
    else
        ier = 0;
        ifiletype = 0;
        # MWF77_get_filetype(cstring[1000] fnameuse, inout int[1] ifiletype, inout int[1] ier);
        if ier > 0
            error('MULTISCALE_MESHER: error determining file type\n');
        end
    end

    if norder > 20 || norder < 1
        error('MULTISCALE_MESHER: norder too high, must be less than 20');
    end
    
    if norder_skel > 20 || norder < 1
        error('MULTISCALE_MESHER: opts.nquad too high, must be less than 20');
    end
    ier = 0;
    # MWF77_multiscale_mesher(cstring[1000] fnameuse, int[1] ifiletype, int[1] norder_skel, int[1] norder_smooth, int[1] nrefine, int[1] adapt_sigma, double[1] rlam, cstring[1000] fnameoutuse, inout int[1] ier);

    if ier == 3 || ier == 4
        error_message = ['MULTISCALE_MESHER: error in main smoothing routine', ...
                'try a larger value of rlam (if not set, use opts.rlam and set it to ',...
                'a value greater than 10)\n' ...
                'if that does not work, then mesh cannot be smooth with the surface smoother\n'];
        error(error_message);
    end

    S = cell(1,nrefine+1); 
    for i=0:nrefine
        fname = fullfile(d.folder, ['/tmp_o' num2str(norder,'%02.f') '_r' num2str(i,'%02.f') '.go3']);
        S{i+1} = surfer.load_from_file(fname);
        delete(fname);
    end
end
%
%
%  Geometry routines
%
%
%
%--------------------------------------------
@ +geometries/ellipsoid.m
function [S] = ellipsoid(abc, nabc, c0, norder, iptype)
% GEOMETRIES.ELLIPSOID, get surface object for an ellipsoid
% whose major axes are along the coordinate directions
%
%
%  Syntax
%   S = geometries.ellipsoid(abc)
%   S = geometries.ellipsoid(abc, nabc)
%   S = geometries.ellipsoid(abc, nabc, c0)
%   S = geometries.ellipsoid(abc, nabc, c0, norder)
%   S = geometries.ellipsoid(abc, nabc, c0, norder, iptype)
%
%  Input arguments:
%    * abc(3): semi-major axes in x,y, and z directions 
%    * nabc(3): (optional, [2,2,2])
%        number of pathes along the coordinate directions of the
%        cube from which the ellipsoid is constructed
%    * c0(3): (optional, [0,0,0])
%        cetner of the ellipsoid
%    * norder: (optional, 4)
%        order of discretization
%    * iptype: (optional, 1)
%        type of patch to be used in the discretization
%        * iptype = 1, triangular patch discretized using
%                      Rokhlin-Vioreanu nodes
%        * iptype = 11, quadrangular patch discretized using tensor
%                       product Gauss-Legendre nodes
%        * iptype = 12, quadrangular patch discretized using tensor
%                       product Chebyshev 
%
  if nargin < 2
    nabc = [2; 2; 2];
  end

  if nargin < 3
    c0 = [0; 0; 0];
  end

  if nargin < 4
    norder = 4;
  end

  if nargin < 5
    iptype = 1;
  end

  npatches = 0;
  npts = 0;
  
  # FORTRAN get_ellipsoid_npat_mem(double[3] abc, int[3] nabc, double[3] c0, int[1] norder, int[1] iptype, inout int[1] npatches, inout int[1] npts);
  

  srcvals = zeros(12,npts);
  srccoefs = zeros(9,npts);

  npatp1 = npatches + 1;
  ixyzs = zeros(npatp1,1);
  norders = zeros(npatches,1);
  iptypes = zeros(npatches,1);

  n9 = 9;
  n12 = 12;

  # FORTRAN get_ellipsoid_npat(double[3] abc, int[3] nabc, double[3] c0, int[1] norder, int[1] iptype, int[1] npatches, int[1] npts, inout int[npatches] norders, inout int[npatp1] ixyzs, inout int[npatches] iptypes, inout double[n9,npts] srccoefs, inout double[n12,npts] srcvals);

  S = surfer(npatches, norder, srcvals, iptype);


end
%
%
%-------------------------------------------------------------
@ +geometries/sphere.m
function [S] = sphere(a, na, c0, norder, iptype)
% GEOMETRIES.SPHERE, get surface object for a sphere 
%
%  Syntax
%   S = geometries.sphere(a)
%   S = geometries.sphere(a, na)
%   S = geometries.sphere(a, na, c0)
%   S = geometries.sphere(a, na, c0, norder)
%   S = geometries.sphere(a, na, c0, norder, iptype)
%
%  Input arguments:
%    * a: radius of the sphere 
%    * na: (optional, 2) 
%        number of pathes along the coordinate directions of the
%        cube from which the sphere is constructed
%    * c0(3): (optional, [0,0,0])
%        cetner of the sphere
%    * norder: (optional, 4)
%        order of discretization
%    * iptype: (optional, 1)
%        type of patch to be used in the discretization
%        * iptype = 1, triangular patch discretized using
%                      Rokhlin-Vioreanu nodes
%        * iptype = 11, quadrangular patch discretized using tensor
%                       product Gauss-Legendre nodes
%        * iptype = 12, quadrangular patch discretized using tensor
%                       product Chebyshev 
%
  if nargin < 2
    na = 2;
  end

  if nargin < 3
    c0 = [0; 0; 0];
  end

  if nargin < 4
    norder = 4;
  end

  if nargin < 5
    iptype = 1;
  end

  abc = [a; a; a];
  nabc = [na; na; na];

  S = geometries.ellipsoid(abc, nabc, c0, norder, iptype);

end
%
%
%
%
%--------------------------------------------
@ +geometries/startorus.m
function [S] = startorus(radii, nosc, scales, nuv, norder, iptype)
% GEOMETRIES.startorus, get toroidal double fourier surface given by
%
% x(u,v) = \rho(u) \cos(v) scales(1)
% y(u,v) = \rho(u) \sin(v) scales(2)
% z(u,v) = z(u) scales(3)
%
% u,v \in [0, 2\pi)^2, and
%
% \rho(u) = Rmajor + r(u)*cos(u)
% z(u) = r(u)*sin(u)
%
% r(u) = rminor + rwave*cos(nosc*u)
%
%  Syntax
%   S = geometries.startorus(radii)
%   S = geometries.startorus(radii, nosc)
%   S = geometries.startorus(radii, nosc, scales)
%   S = geometries.startorus(radii, nosc, scales, nuv)
%   S = geometries.startorus(radii, nosc, scales, nuv, norder)
%   S = geometries.startorus(radii, nosc, scales, nuv, norder, iptype)
%
%  Input arguments:
%    * radii(3): radii of star shaped torus
%         radii(1) = rmajor
%         radii(2) = rminor
%         radii(3) = rwave
%    * nosc(1): integer (optional, 0)
%         number of oscillations in star-shaped torus
%    * scales(3): (optional, [1,1,1])
%        scaling parameters for the coordinates of the surface
%    * nuv(2): integer (optional, [5,5])
%        number of quad patches in u, and v direction. if iptype is 1,
%        then each quad patch is further divided into two triangular
%        patches
%    * norder: (optional, 4)
%        order of discretization
%    * iptype: (optional, 1)
%        type of patch to be used in the discretization
%        * iptype = 1, triangular patch discretized using
%                      Rokhlin-Vioreanu nodes
%        * iptype = 11, quadrangular patch discretized using tensor
%                       product Gauss-Legendre nodes
%        * iptype = 12, quadrangular patch discretized using tensor
%                       product Chebyshev 
%

  if nargin < 2
     nosc = 0;
  end

  if nargin < 3
    scales = [1;1;1];
  end

  if nargin < 4
    nuv = [5;5];
  end

  if nargin < 5
    norder = 4;
  end

  if nargin < 6
    iptype = 1;
  end

  m = nosc + 1;
  coefs = zeros(2*m+1, 2*m+1, 3);

  coefs(1,1,1) = radii(1);
  coefs(2,1,1) = radii(2);
  coefs(1+nosc,1,1) = radii(3)/2;
  coefs(1+abs(nosc-1),1,1) = radii(3)/2;

  coefs(m+2,1,3) = radii(2);
  coefs(2*m+1,1,3) = radii(3)/2;

  if nosc-1 > 0
    coefs(m+1+nosc-1,1,3) = -radii(3)/2;
  end

  if nosc-1 < 0
    coefs(m+1+abs(nosc-1),1,3) = radii(3)/2;
  end

  iort = 1;

  S = geometries.xyz_tensor_fourier(coefs, scales, iort, nuv, norder, iptype);


end
%
%
%
%
%
%--------------------------------------------
@ +geometries/stellarator.m
function [S] = stellarator(nuv, norder, iptype)
% GEOMETRIES.stellarator, get toroidal double fourier surface given by
%
% x(u,v) = hat(x)(u,v) \cos(v)
% y(u,v) = hat(x)(u,v) \sin(v)  
% z(u,v) = hat(z)(u,v)
%
% u,v \in [2\pi,0)\times [0,2\pi) , and
%
% hat(x) = \sum_{i=1}^{2m+1} \sum_{j=0}^{2m+1} x_{ij} b_{i} (u) b_{j} (v)
% hat(z) = \sum_{i=1}^{2m+1} \sum_{j=0}^{2m+1} z_{ij} b_{i} (u) b_{j} (v)
%
% with m = 2, and the only non-zero coefs are given by
%
% hat(x)(3,2) = 0.17
% hat(x)(5,4) = 0.17
% hat(x)(1,1) = 4.5
% hat(x)(2,1) = 0.75
% hat(x)(3,1) = 0.11
% hat(x)(2,2)  -0.38
% hat(x)(4,4) = -0.52
%
% hat(z)(5,2) = 0.17
% hat(z)(3,4) = -0.17
% hat(z)(5,1) = 0.11
% hat(z)(4,2) = 0.52
% hat(z)(2,4) = -0.38
%
%  Syntax
%   S = geometries.stellarator()
%   S = geometries.stellarator(nuv)
%   S = geometries.stellarator(nuv, norder)
%   S = geometries.stellarator(nuv, norder, iptype)
%
%  Input arguments:
%    * nuv(2): integer (optional, [5,15])
%        number of quad patches in u, and v direction. if iptype is 1,
%        then each quad patch is further divided into two triangular
%        patches
%    * norder: (optional, 4)
%        order of discretization
%    * iptype: (optional, 1)
%        type of patch to be used in the discretization
%        * iptype = 1, triangular patch discretized using
%                      Rokhlin-Vioreanu nodes
%        * iptype = 11, quadrangular patch discretized using tensor
%                       product Gauss-Legendre nodes
%        * iptype = 12, quadrangular patch discretized using tensor
%                       product Chebyshev 
%

  if nargin < 1
    nuv = [5;15];
  end

  if nargin < 2
    norder = 4;
  end

  if nargin < 3
    iptype = 1;
  end

  m = 2; 
  coefs = zeros(2*m+1, 2*m+1, 3);

  coefs(3,2,1) = 0.17;
  coefs(5,4,1) = 0.17;
  coefs(1,1,1) = 4.5;
  coefs(2,1,1) = 0.75;
  coefs(3,1,1) = 0.11;
  coefs(2,2,1) = -0.38;
  coefs(4,4,1) = -0.52;

  coefs(5,2,3) = 0.17;
  coefs(3,4,3) = -0.17;
  coefs(4,1,3) = 1.25;
  coefs(5,1,3) = 0.11;
  coefs(4,2,3) = 0.52;
  coefs(2,4,3) = -0.38;
  
  scales = [1;1;1];


  iort = -1;

  S = geometries.xyz_tensor_fourier(coefs, scales, iort, nuv, norder, iptype);


end
%
%
%

%
%--------------------------------------------
@ +geometries/xyz_tensor_fourier.m
function [S] = xyz_tensor_fourier(coefs, scales, iort, nuv, norder, iptype)
% GEOMETRIES.xyz_tensor_fourier, get toroidal double fourier surface given by
%
% hat(x) = \sum_{i=1}^{2m+1} \sum_{j=0}^{2m+1} x_{ij} b_{i} (u) b_{j} (v)
% hat(y) = \sum_{i=1}^{2m+1} \sum_{j=0}^{2m+1} y_{ij} b_{i} (u) b_{j} (v)
% hat(z) = \sum_{i=1}^{2m+1} \sum_{j=0}^{2m+1} z_{ij} b_{i} (u) b_{j} (v)
%
% x(u,v) = (hat(x) \cos(v) - hat(y) sin(v))*scales(1)
% y(u,v) = (hat(x) \sin(v) + hat(y) cos(v))*scales(2)
% z(u,v) = hat(z)*scales(3)
%
% u,v \in [0, 2\pi)^2, and
%
% b_{i}(u) = \{ 1, cos(u), \ldots cos(m u), sin(u), \ldots sin(m u) \}
%
%
%  Syntax
%   S = geometries.xyz_tensor_fourier(coefs)
%   S = geometries.xyz_tensor_fourier(coefs, scales)
%   S = geometries.xyz_tensor_fourier(coefs, scales, iort)
%   S = geometries.xyz_tensor_fourier(coefs, scales, iort, nuv)
%   S = geometries.xyz_tensor_fourier(coefs, scales, iort, nuv, norder)
%   S = geometries.xyz_tensor_fourier(coefs, scales, iort, nuv, norder, iptype)
%
%  Input arguments:
%    * coefs(2*m+1, 2*m+1, 3): Fourier coefs
%         hat(x) = coefs(:,:,1)
%         hat(y) = coefs(:,:,2)
%         hat(z) = coefs(:,:,3)
%    * scales(3): (optional, [1,1,1])
%        scaling parameters for the coordinates of the surface
%    * iort: integer (optional, 1)
%        orientation flag
%        if iort = 1, then parameter space is [0, 2\pi)^2
%        if iort = -1, then parameter space is [2\pi, 0) \times [0, 2\pi)
%    * nuv(2): integer (optional, [5,5])
%        number of quad patches in u, and v direction. if iptype is 1,
%        then each quad patch is further divided into two triangular
%        patches
%    * norder: (optional, 4)
%        order of discretization
%    * iptype: (optional, 1)
%        type of patch to be used in the discretization
%        * iptype = 1, triangular patch discretized using
%                      Rokhlin-Vioreanu nodes
%        * iptype = 11, quadrangular patch discretized using tensor
%                       product Gauss-Legendre nodes
%        * iptype = 12, quadrangular patch discretized using tensor
%                       product Chebyshev 
%

  if nargin < 2
    scales = [1;1;1];
  end

  if nargin < 3
    iort = 1; 
  end

  if nargin < 4
    nuv = [5;5];
  end

  if nargin < 5
    norder = 4;
  end

  if nargin < 6
    iptype = 1;
  end

  mm = length(size(coefs));
  if mm ~= 3
    error('GEOMETRIES.XYZ_TENSOR_FOURIER: coefs must be a three dimensional tensor');
  end

  [m1, m2, m3] = size(coefs);
  if (m1 ~= m2)
    error('GEOMETRIES.XYZ_TENSOR_FOURIER: first two dimensions of coefs must be of same size');
  end

  if mod(m1, 2) ~= 1
    error('GEOMETRIES.XYZ_TENSOR_FOURIER: first two dimensions of coefs must be odd');
  end

  if m3 ~=3 
    error('GEOMETRIES.XYZ_TENSOR_FOURIER: last dimension of coefs array must be 3');
  end

  m = (m1-1)/2;

  muse = m1*m2;
  coefs_use = reshape(coefs, [muse, 3]);

  npatches = 0;
  npts = 0;
  
  # FORTRAN get_xyz_tensor_fourier_npat_mem(double[muse,3] coefs_use, int[1] m, double[3] scales, int[1] iort, int[2] nuv, int[1] norder, int[1] iptype, inout int[1] npatches, inout int[1] npts);
  

  srcvals = zeros(12,npts);
  srccoefs = zeros(9,npts);

  npatp1 = npatches + 1;
  ixyzs = zeros(npatp1,1);
  norders = zeros(npatches,1);
  iptypes = zeros(npatches,1);

  n9 = 9;
  n12 = 12;

  # FORTRAN get_xyz_tensor_fourier_npat(double[muse,3] coefs_use, int[1] m, double[3] scales, int[1] iort, int[2] nuv, int[1] norder, int[1] iptype, int[1] npatches, int[1] npts, inout int[npatches] norders, inout int[npatp1] ixyzs, inout int[npatches] iptypes, inout double[n9,npts] srccoefs, inout double[n12,npts] srcvals);

  S = surfer(npatches, norder, srcvals, iptype);


end
%
%
%-------------------------------------------------------------

%
%
%
%%   Common routines
%%
%
%-------------------------------------------------
@ src/get_oversampling_parameters.m
function [novers,varargout] = get_oversampling_parameters(S,Q,eps)
%
%  get_oversampling_parameters
%     subroutine to estimate the oversampling paramters for a given
%     surface, and set of quadrature corrections stored in Q
%  
%  Syntax
%    Q = get_oversampling_parameters(S,Q,eps)
%
%  Input arguments
%    * S: surfer object, see README.md in matlab for details
%    * Q: quadrature correction struct, necessary components are
%            Q.targinfo, Q.rfac, Q.wavenumber, Q.row_ptr, Q.col_ind
%    * eps: tolerance
%
    
%
%  extract arrays
%
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    n3 = 3;

    cms = zeros(3,npatches);
    rads = zeros(npatches,1);
    # FORTRAN get_centroid_rads(int[1] npatches,int[npatches] norders,int[npatp1] ixyzs,int[npatches] iptype,int[1] npts,double[n9,npts] srccoefs,inout double[n3,npatches] cms,inout double[npatches] rads);

    novers = zeros(npatches,1);
    ixyzso = zeros(npatp1,1);

    targinfo = Q.targinfo;

    targs = extract_targ_array(targinfo);
    [ndtarg,ntarg] = size(targs);

    ntp1 = ntarg + 1;
    zk = Q.wavenumber;
    ikerorder = Q.kernel_order;
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    nnz = length(col_ind);
    rfac = Q.rfac;


    # FORTRAN get_far_order(double[1] eps, int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, double[3,npatches] cms, double[npatches] rads, int[1] npts, double[n9,npts] srccoefs, int[1] ndtarg, int[1] ntarg, double[ndtarg,ntarg] targs, int[1] ikerorder, dcomplex[1] zk, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, double[1] rfac, inout int[npatches] novers, inout int[npatp1] ixyzso);
    varargout{1} = ixyzso;

end


%
%
%
%
%
%-------------------------------------------------
@ src/get_surface_laplacian.m
function [surf_lap_p] = get_surface_laplacian(S,p)
%
%  
%  surf_lap_p = get_surface_laplacian(S,p)
%    This subrorutine evaluates the surface laplacian of a given 
%    function p
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * p: input function on surface
%
%  Output arguments:
%    * surf_lap_p: surface laplcian of p
%

% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    nd0 = 1;
    n2 = 2;


    dp = zeros(2,npts);
    # FORTRAN get_surf_grad(int[1] nd0, int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, double[npts] p, inout double[n2,npts] dp);

    surf_lap_p = zeros(size(p));
    # FORTRAN get_surf_div(int[1] nd0, int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, double[n2,npts] dp, inout double[npts] surf_lap_p);

    surf_lap_p = reshape(surf_lap_p,size(p));

end
%
%
%
%
%
@ src/get_surface_grad.m
function [surf_grad] = get_surface_grad(S,p,varargin)
%
%
%
%  surf_grad = get_surfgrad(S,p)
%     This subroutine evaluates the surface gradient of a given function
%     p and returns the gradient in cartesian coordinates (default) or 
%     in the dxyz/du, and dxyz/dv basis 
%
%  Input arguments:
%    * S: surfer object
%    * p: input function on surface
%    * opts: options struct (optional)
%        opts.iscartesian (true): return surface gradient in
%           cartesian coordiantes if true, else return
%           and dxyz/du and dxyz/dv components
%
%  Output arguments:
%    * surf_grad: double (3,S.npts) or double (2,npts)
%        depending on the flag opts.iscartesian
%

    opts = [];
    if(nargin == 3)
       opts = varargin{1};
    end

    iscartesian = true;
    if(isfield(opts,'iscartesian'))
        iscartesian = opts.iscartesian;
    end
     
% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    if(isreal(p))
        nd0 = 1;
        p = reshape(p,[1,npts]);
    else
        nd0 = 2;
        p = [real(p(:)) imag(p(:))].';
    end
    n2 = 2;


    nduse = nd0*n2;



    dp = zeros(nduse,npts);
    # FORTRAN get_surf_grad(int[1] nd0, int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, double[nd0,npts] p, inout double[nduse,npts] dp);
    
    if(nd0 ~= 1)
        dp = dp(1:2:4,1:npts) + 1j*dp(2:2:4,1:npts); 
    end
    if(~iscartesian)
        surf_grad = dp;
    else
        surf_grad = repmat(dp(1,1:npts),[3,1]).*srcvals(4:6,1:npts) + repmat(dp(2,1:npts),[3,1]).*srcvals(7:9,1:npts);
    end
end

%
%
%
%
%

%-------------------------------------------------
%
%%
%%   Laplace dirichlet routines
%
%
%-------------------------------------------------

@ +lap3d/+dirichlet/eval.m 
function p = eval(S,sigma,targinfo,eps,dpars,varargin)
%
%  lap3d.dirichlet.eval
%    Evaluates the Laplace dirichlet layer potential at a collection 
%    of targets
%
%  Syntax
%   pot = lap3d.dirichlet.eval(S,sigma,targinfo,eps,dpars)
%   pot = lap3d.dirichlet.eval(S,sigma,targinfo,eps,dpars,opts)
%
%  Integral representation
%     pot = \alpha S_{0} [\sigma] + \beta D_{0} [\sigma]
%
%  S_{0}, D_{0}: Laplace single and double layer potential
%  
%  \alpha, beta = dpars(1:2)
%
%  Note: for targets on surface, only principal value part of the
%    layer potential is returned
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * sigma: layer potential density
%    * targinfo: target info 
%       targinfo.r = (3,nt) target locations
%       targinfo.patch_id (nt,) patch id of target, = -1, if target
%          is off-surface (optional)
%       targinfo.uvs_targ (2,nt) local uv ccordinates of target on
%          patch if on-surface (optional)
%    * eps: precision requested
%    * dpars: kernel parameters
%        dpars(1) - single layer strength
%        dpars(2) - double layer strength
%    * opts: options struct
%        opts.nonsmoothonly - use smooth quadrature rule for evaluating
%           layer potential (false)
%        opts.precomp_quadrature: precomputed quadrature corrections struct 
%           currently only supports quadrature corrections
%           computed in rsc format 
%    

    if(nargin < 6) 
      opts = [];
    else
      opts = varargin{1};
    end

    nonsmoothonly = false;
    if(isfield(opts,'nonsmoothonly'))
      nonsmoothonly = opts.nonsmoothonly;
    end
    
    isprecompq = false;
    if isfield(opts, 'precomp_quadrature')
      isprecompq = true;
      Q = opts.precomp_quadrature;
    end

    if(isprecompq)
      if ~(strcmpi(Q.format,'rsc'))
        fprintf('Invalid precomputed quadrature format\n');
        fprintf('Ignoring quadrature corrections\n');
        opts_qcorr = [];
        opts_qcorr.type = 'double';
        Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
      end
    end

% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    ff = 'rsc';

    [targs] = extract_targ_array(targinfo);
    [ndtarg,ntarg] = size(targs);
    ntargp1 = ntarg+1;

% Compute quadrature corrections   
    if ~isprecompq
      if ~nonsmoothonly
        opts_quad = [];
        opts_quad.format = 'rsc';
%
%  For now Q is going to be a struct with 'quad_format', 
%  'nkernels', 'pde', 'bc', 'kernel', 'ker_order',
%  and either, 'wnear', 'row_ind', 'col_ptr', or
%  with 'spmat' as a sparse matrix or a cell array of wnear/spmat
%  if nkernel is >1
%

        [Q] = lap3d.dirichlet.get_quadrature_correction(S,eps,dpars,targinfo,opts_quad);
      else
        opts_qcorr = [];
        opts_qcorr.type = 'double';
        Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
      end
    end
    nquad = Q.iquad(end)-1;
    nnz = length(Q.col_ind);
    nnzp1 = nnz+1; 

    [novers] = get_oversampling_parameters(S,Q,eps);
    Sover = oversample(S,novers);


% Extract oversampled arrays

    [srcover,~,~,ixyzso,~,wover] = extract_arrays(Sover);
    nptso = Sover.npts; 

% Extract quadrature arrays
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    iquad = Q.iquad;
    wnear = Q.wnear;

    p = zeros(ntarg,1);

    ndd = 2;
    ndz = 0;
    zpars = [];
    ndi = 0;
    ipars = [];
    nker = 1;
    lwork = 0;
    work = [];
    ndim = 1;
    idensflag = 0;
    ipotflag = 0;
    ndim_p = 1;

% Call the layer potential evaluator
    # FORTRAN lap_comb_dir_eval_addsub(int[1] npatches,int[npatches] norders, int[npatp1] ixyzs,int[npatches] iptype, int[1] npts,double[n9,npts] srccoefs,double[n12,npts] srcvals,int[1] ndtarg, int[1] ntarg, double[ndtarg,ntarg] targs, double[1] eps,int[1] ndd, double[ndd] dpars, int[1] ndz, dcomplex[ndz] zpars, int[1] ndi, int[ndi] ipars, int[1] nnz, int[ntargp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, int[1] nquad,int[1] nker, double[nquad] wnear,  int[npatches] novers, int[1] nptso, int[npatp1] ixyzso,double[12,nptso] srcover, double[nptso] wover, int[1] lwork, double[lwork] work, int[1] idensflag, int[1] ndim, double[npts] sigma, int[1] ipotflag, int[1] ndim_p, inout double[ntarg] p);   
end    
%
%
%
%----------------------------------
%
@ +lap3d/+dirichlet/get_quadrature_correction.m 
function Q = get_quadrature_correction(S, eps, dpars, targinfo, opts)
%
%  lap3d.dirichlet.get_quadrature_correction
%    This subroutine returns the near quadrature correction
%    for the combined field representation with density supported
%    on the surface S, and targets given by targinfo 
%    as a sparse matrix/rsc format 
%
%  Syntax
%   Q = lap3d.dirichlet.get_quadrature_correction(S,eps,dpars)
%   Q = lap3d.dirichlet.get_quadrature_correction(S,eps,dpars,targinfo)
%   Q = lap3d.dirichlet.get_quadrature_correction(S,eps,dpars,targinfo,opts)
%
%  Integral representation
%     pot = \alpha S_{0} [\sigma] + \beta D_{0} [\sigma]
%
%  S_{0}, D_{0}: Laplace single and double layer potential
%  
%  \alpha, beta = dpars(1:2)
%
%  Note: for targets on surface, only principal value part of the
%    layer potential is returned
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * eps: precision requested
%    * dpars: kernel parameters
%        dpars(1) - single layer strength
%        dpars(2) - double layer strength
%    * targinfo: target info (optional)
%       targinfo.r = (3,nt) target locations
%       targinfo.du = u tangential derivative info
%       targinfo.dv = v tangential derivative info
%       targinfo.n = normal info
%       targinfo.patch_id (nt,) patch id of target, = -1, if target
%          is off-surface (optional)
%       targinfo.uvs_targ (2,nt) local uv ccordinates of target on
%          patch if on-surface (optional)
%    * opts: options struct
%        opts.format - Storage format for sparse matrices
%           'rsc' - row sparse compressed format
%           'csc' - column sparse compressed format
%           'sparse' - sparse matrix format
%        opts.quadtype - quadrature type, currently only 'ggq' supported
%

    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;
    npp1 = npatches+1;
    n3 = 3;


    if nargin < 4
      targinfo = [];
      targinfo.r = S.r;
      targinfo.du = S.du;
      targinfo.dv = S.dv;
      targinfo.n = S.n;
      targinfo.patch_id = S.patch_id;
      targinfo.uvs_targ = S.uvs_targ;
      opts = [];
    end

    if nargin < 5
      opts = [];

    end

    ff = 'rsc';
    if(isfield(opts,'format'))
       ff = opts.format;
    end

    if(~(strcmpi(ff,'rsc') || strcmpi(ff,'csc') || strcmpi(ff,'sparse')))
       fprintf('invalid quadrature format, reverting to rsc format\n');
       ff = 'rsc';
    end


    targs = extract_targ_array(targinfo); 
    [ndtarg,ntarg] = size(targs);
    ntargp1 = ntarg+1;
    
    if(isfield(targinfo,'patch_id') || isprop(targinfo,'patch_id'))
      patch_id = targinfo.patch_id;
    else
      patch_id = zeros(ntarg,1);
    end

    if(isfield(targinfo,'uvs_targ') || isprop(targinfo,'uvs_targ'))
      uvs_targ = targinfo.uvs_targ;
    else
      uvs_targ = zeros(2,ntarg);
    end

    if(length(patch_id)~=ntarg)
      fprintf('Incorrect size of patch id in target info struct. Aborting! \n');
    end

    [n1,n2] = size(uvs_targ);
    if(n1 ~=2 && n2 ~=ntarg)
      fprintf('Incorrect size of uvs_targ array in targinfo struct. Aborting! \n');
    end


    
    iptype0 = iptype(1);
    norder0 = norders(1);
    rfac = 0.0;
    rfac0 = 0.0;
    # FORTRAN get_rfacs(int[1] norder0, int[1] iptype0, inout double[1] rfac, inout double[1] rfac0);
    

    cms = zeros(3,npatches);
    rads = zeros(npatches,1);
    # FORTRAN get_centroid_rads(int[1] npatches,int[npatches] norders,int[npp1] ixyzs,int[npatches] iptype,int[1] npts,double[n9,npts] srccoefs,inout double[n3,npatches] cms,inout double[npatches] rads);

    rad_near = rads*rfac;
    nnz = 0;
    # FORTRAN findnearmem(double[n3,npatches] cms,int[1] npatches,double[npatches] rad_near,int[1] ndtarg,double [ndtarg,ntarg] targs,int[1] ntarg,inout int[1] nnz);

    row_ptr = zeros(ntarg+1,1);
    col_ind = zeros(nnz,1);
    ntp1 = ntarg+1;
    nnzp1 = nnz+1;
    # FORTRAN findnear(double[n3,npatches] cms,int[1] npatches,double[npatches] rad_near,int[1] ndtarg,double [ndtarg,ntarg] targs, int[1] ntarg,inout int[ntp1] row_ptr,inout int[nnz] col_ind); 

    iquad = zeros(nnz+1,1);
    # FORTRAN get_iquad_rsc(int[1] npatches,int[npp1] ixyzs,int[1] npts,int[1] nnz,int[ntp1] row_ptr,int[nnz] col_ind,inout int[nnzp1] iquad);

    nquad = iquad(nnz+1)-1;
    wnear = zeros(nquad,1);
    iquadtype = 1;
    if(isfield(opts,'quadtype'))
      if(strcmpi(opts.quadtype,'ggq'))
         iquadtype = 1;
      else
        fprintf('Unsupported quadrature type, reverting to ggq\n');
        iquadtype = 1;
      end
    end
    # FORTRAN getnearquad_lap_comb_dir_eval(int[1] npatches,int[npatches] norders,int[npp1] ixyzs,int[npatches] iptype,int[1] npts,double[n9,npts] srccoefs,double[n12,npts] srcvals,int[1] ndtarg,int[1] ntarg,double[ndtarg,ntarg] targs, int[ntarg] patch_id, double[2,ntarg] uvs_targ,double[1] eps,double[2] dpars,int[1] iquadtype,int[1] nnz,int[ntp1] row_ptr,int[nnz] col_ind,int[nnzp1] iquad,double[1] rfac0,int[1] nquad,inout double[nquad] wnear);
    
    Q = [];
    Q.targinfo = targinfo;
    Q.ifcomplex = 0;
    Q.wavenumber = 0; 
    Q.kernel_order = -1;
    Q.rfac = rfac;
    Q.nquad = nquad;
    Q.format = ff;
    

    if(abs(dpars(2)) > 1e-16)
        Q.kernel_order = 0;
    end

    if(strcmpi(ff,'rsc'))
        Q.iquad = iquad;
        Q.wnear = wnear;
        Q.row_ptr = row_ptr;
        Q.col_ind = col_ind;
    elseif(strcmpi(ff,'csc'))
        col_ptr = zeros(npatches+1,1);
        row_ind = zeros(nnz,1);
        iper = zeros(nnz,1);
        npatp1 = npatches+1;
        # FORTRAN rsc_to_csc(int[1] npatches, int[1] ntarg, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, inout int[npatp1] col_ptr, inout int[nnz] row_ind, inout int[nnz] iper); 
        Q.iquad = iquad;
        Q.iper = iper;
        Q.wnear = wnear;
        Q.col_ptr = col_ptr;
        Q.row_ind = row_ind;
    else
        spmat = conv_rsc_to_spmat(S,row_ptr,col_ind,wnear);
        Q.spmat = spmat;
    end
    
end
%
%
%
%
%-------------------------------------------------

@ +lap3d/+dirichlet/solver.m 
function [sigma,varargout] = solver(S, rhs, eps, dpars, opts)
%
%  lap3d.dirichlet.solver
%    Solve the Laplace dirichlet boundary value problem
%
%  Syntax
%   sigma = lap3d.dirichlet.solver(S,sigma,eps,dpars)
%   sigma = lap3d.dirichlet.solver(S,sigma,eps,dpars,opts)
%
%  Integral representation
%     pot = \alpha S_{0} [\sigma] + \beta D_{0} [\sigma]
%
%  S_{0}, D_{0}: Laplace single and double layer potential
%  
%  \alpha, beta = dpars(1:2)
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * rhs: boundary data 
%    * eps: precision requested
%    * dpars: kernel parameters
%        dpars(1) - single layer strength
%        dpars(2) - double layer strength
%    * opts: options struct
%        opts.nonsmoothonly - use smooth quadrature rule for evaluating
%           layer potential (false)
%        opts.eps_gmres - tolerance to which linear system is to be
%           solved (eps_gmres = eps)
%        opts.maxit - maximum number of gmres iterations (200)
%        opts.ifout - whether to solve interior problem or not (1)
%        opts.quadrature_correction - precomputed quadrature correction ([])
%        
%
%  Output arguemnts:
%    * sigma: layer potential density
%    
%
    
    if(nargin < 5) 
      opts = [];
    end

    nonsmoothonly = false;
    if(isfield(opts,'nonsmoothonly'))
      nonsmoothonly = opts.nonsmoothonly;
    end

    eps_gmres = eps;
    if(isfield(opts,'eps_gmres'))
      eps_gmres = opts.eps_gmres;
    end

    maxit = 200;
    if(isfield(opts,'maxit'))
      maxit = opts.maxit;
    end

    ifout = 1;
    if(isfield(opts,'ifout'))
      ifout = opts.ifout;
    end

% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    targinfo = [];
    targinfo.r = S.r;
    targinfo.du = S.du;
    targinfo.dv = S.dv;
    targinfo.n = S.n;
    patch_id  = zeros(npts,1);
    uvs_targ = zeros(2,npts);
    # FORTRAN get_patch_id_uvs(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, inout int[npts] patch_id, inout double[2,npts] uvs_targ);
    targinfo.patch_id = patch_id;
    targinfo.uvs_targ = uvs_targ;

    ff = 'rsc';

    nptsp1 = npts+1;

% Compute quadrature corrections    
    if(~nonsmoothonly)

      if isfield(opts, 'quadrature_correction')
         Q = opts.quadrature_correction;
      else
        opts_quad = [];
        opts_quad.format = 'rsc';
%
%  For now Q is going to be a struct with 'quad_format', 
%  'nkernels', 'pde', 'bc', 'kernel', 'ker_order',
%  and either, 'wnear', 'row_ind', 'col_ptr', or
%  with 'spmat' as a sparse matrix or a cell array of wnear/spmat
%  if nkernel is >1
%

        [Q] = lap3d.dirichlet.get_quadrature_correction(S,eps,dpars,targinfo,opts_quad);
      end
    else
      opts_qcorr = [];
      opts_qcorr.type = 'double';
      Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
    end
    nnz = length(Q.col_ind);
    nquad = Q.iquad(end)-1;
    nnzp1 = nnz+1; 

    [novers] = get_oversampling_parameters(S,Q,eps);
    Sover = oversample(S,novers);


% Extract oversampled arrays

    [srcover,~,~,ixyzso,~,wover] = extract_arrays(Sover);
    nptso = Sover.npts; 

% Extract quadrature arrays
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    iquad = Q.iquad;
    wnear = Q.wnear;


    sigma = zeros(npts,1);
    niter = 0;
    errs = zeros(maxit+1,1);
    maxitp1 = maxit + 1;
    rres = 0;
    nker = 1;

% Call the layer potential evaluator
    # FORTRAN lap_comb_dir_solver_guru(int[1] npatches,int[npatches] norders, int[npatp1] ixyzs,int[npatches] iptype, int[1] npts,double[n9,npts] srccoefs,double[n12,npts] srcvals, double[1] eps, double[2] dpars, int[1] maxit, int[1] ifout, double[npts] rhs, int[1] nnz, int[nptsp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, int[1] nquad, int[1] nker, double[nquad] wnear, int[npatches] novers, int[1] nptso, int[npatp1] ixyzso, double[12,nptso] srcover, double[nptso] wover, double[1] eps_gmres, inout int[1] niter, inout double[maxitp1] errs, inout double[1] rres, inout double[npts] sigma);  

    errs = errs(1:niter);
    varargout{1} = errs;
    varargout{2} = rres;
    varargout{3} = Q;
end    
%
%
%-------------------------------------------------
%
%%
%%   Laplace neumann routines
%
%
%-------------------------------------------------

@ +lap3d/+neumann/eval.m 
function p = eval(S,sigma,targinfo,eps,varargin)
%
%  lap3d.neumann.eval
%    Evaluates the Laplace neumann layer potential at a collection 
%    of targets
%
%  Syntax
%   pot = lap3d.neumann.eval(S,sigma,targinfo,eps)
%   pot = lap3d.neumann.eval(S,sigma,targinfo,eps,opts)
%
%  Integral representation
%     pot = S_{0} [\sigma] 
%
%  S_{0}: Laplace single layer potential
%  
%  Note: for targets on surface, only principal value part of the
%    layer potential is returned
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * sigma: layer potential density
%    * targinfo: target info (optional)
%       targinfo.r = (3,nt) target locations
%       targinfo.patch_id (nt,) patch id of target, = -1, if target
%          is off-surface (optional)
%       targinfo.uvs_targ (2,nt) local uv ccordinates of target on
%          patch if on-surface (optional)
%    * opts: options struct
%    * eps: precision requested
%        opts.nonsmoothonly - use smooth quadrature rule for evaluating
%           layer potential (false)
%        opts.precomp_quadrature: precomputed quadrature corrections 
%           struct currently only supports quadrature corrections
%           computed in rsc format 
%    

    if(nargin < 5) 
      opts = [];
    else
      opts = varargin{1};
    end

    nonsmoothonly = false;
    if(isfield(opts,'nonsmoothonly'))
      nonsmoothonly = opts.nonsmoothonly;
    end

    isprecompq = false;
    if isfield(opts, 'precomp_quadrature')
      isprecompq = true;
      Q = opts.precomp_quadrature;
    end
    
    if(isprecompq)
      if ~(strcmpi(Q.format,'rsc'))
        fprintf('Invalid precomputed quadrature format\n');
        fprintf('Ignoring quadrature corrections\n');
        opts_qcorr = [];
        opts_qcorr.type = 'double';
        Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
      end
    end

% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    ff = 'rsc';

    [targs] = extract_targ_array(targinfo);
    [ndtarg,ntarg] = size(targs);
    ntargp1 = ntarg+1;

% Compute quadrature corrections   
    if ~isprecompq
      if ~nonsmoothonly
        opts_quad = [];
        opts_quad.format = 'rsc';
        opts_quad.rep = 'eval';
%
%  For now Q is going to be a struct with 'quad_format', 
%  'nkernels', 'pde', 'bc', 'kernel', 'ker_order',
%  and either, 'wnear', 'row_ind', 'col_ptr', or
%  with 'spmat' as a sparse matrix or a cell array of wnear/spmat
%  if nkernel is >1
%

        [Q] = lap3d.neumann.get_quadrature_correction(S,eps,targinfo,opts_quad);
      else
        opts_qcorr = [];
        opts_qcorr.type = 'double';
        Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
      end
    end
    nquad = Q.iquad(end)-1;
    nnz = length(Q.col_ind);
    nnzp1 = nnz+1; 

    [novers] = get_oversampling_parameters(S,Q,eps);
    Sover = oversample(S,novers);


% Extract oversampled arrays

    [srcover,~,~,ixyzso,~,wover] = extract_arrays(Sover);
    nptso = Sover.npts; 

% Extract quadrature arrays
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    iquad = Q.iquad;
    wnear = Q.wnear;

    p = zeros(ntarg,1);

    ndd = 0;
    dpars = [];
    ndz = 0;
    zpars = [];
    ndi = 0;
    ipars = [];
    nker = 1;
    lwork = 0;
    work = [];
    ndim_s = 1;
    ndim_p = 1;
    idensflag = 1;
    ipotflag = 1;
% Call the layer potential evaluator
    # FORTRAN lap_s_neu_eval_addsub(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, int[1] ndtarg, int[1] ntarg, double[ndtarg,ntarg] targs, double[1] eps, int[1] ndd, double[ndd] dpars, int[1] ndz, dcomplex[ndz] zpars, int[1] ndi, int[ndi] ipars, int[1] nnz, int[ntargp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, int[1] nquad, int[1] nker, double[nquad] wnear,  int[npatches] novers, int[1] nptso, int[npatp1] ixyzso, double[12,nptso] srcover, double[nptso] wover, int[1] lwork, double[lwork] work, int[1] idensflag, int[1] ndim_s, double[npts] sigma, int[1] ipotflag, int[1] ndim_p, inout double[ntarg] p);   
end    
%
%
%
%----------------------------------
%
@ +lap3d/+neumann/get_quadrature_correction.m 
function Q = get_quadrature_correction(S, eps, targinfo, opts)
%
%  lap3d.neumann.get_quadrature_correction
%    This subroutine returns the near quadrature correction
%    for the combined field representation with density supported
%    on the surface S, and targets given by targinfo 
%    as a sparse matrix/rsc format 
%
%  Syntax
%   Q = lap3d.neumann.get_quadrature_correction(S,eps)
%   Q = lap3d.neumann.get_quadrature_correction(S,eps,targinfo)
%   Q = lap3d.neumann.get_quadrature_correction(S,eps,targinfo,opts)
%
%  Integral representation
%     pot = S_{0} [\sigma] 
%
%  S_{0}: Laplace single layer potential
%  
%
%  Note: for targets on surface, only principal value part of the
%    layer potential is returned
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * eps: precision requested
%    * targinfo: target info (optional)
%       targinfo.r = (3,nt) target locations
%       targinfo.du = u tangential derivative info
%       targinfo.dv = v tangential derivative info
%       targinfo.n = normal info
%       targinfo.patch_id (nt,) patch id of target, = -1, if target
%          is off-surface (optional)
%       targinfo.uvs_targ (2,nt) local uv ccordinates of target on
%          patch if on-surface (optional)
%    * opts: options struct
%        opts.format - Storage format for sparse matrices
%           'rsc' - row sparse compressed format
%           'csc' - column sparse compressed format
%           'sparse' - sparse matrix format
%        opts.quadtype - quadrature type, currently only 'ggq' supported
%        opts.rep - whether to compute correction for on surface
%                   integral equation or post-processing
%                   'bc' - on surface integral equation. If option
%                   is 'bc' then targinfo is ignored
%                   'eval' - post-processing
%

    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;
    npp1 = npatches+1;
    nsp1 = npts + 1;
    n3 = 3;

    if nargin < 3
      targinfo = [];
      targinfo.r = S.r;
      targinfo.du = S.du;
      targinfo.dv = S.dv;
      targinfo.n = S.n;
      targinfo.patch_id = S.patch_id;
      targinfo.uvs_targ = S.uvs_targ;
      opts = [];
    end

    qtype = 'bc';

    if nargin < 4
      opts = [];
    end

    if isfield(opts, 'rep')
      qtype = opts.rep;
    end

    ff = 'rsc';
    if(isfield(opts,'format'))
       ff = opts.format;
    end

    if(~(strcmpi(ff,'rsc') || strcmpi(ff,'csc') || strcmpi(ff,'sparse')))
       fprintf('invalid quadrature format, reverting to rsc format\n');
       ff = 'rsc';
    end

    tinfouse = [];
    if strcmpi(qtype, 'bc')
      tinfouse.r = S.r;
      tinfouse.du = S.du;
      tinfouse.dv = S.dv;
      tinfouse.n = S.n;
      tinfouse.patch_id = S.patch_id;
      tinfouse.uvs_targ = S.uvs_targ;
    else
      tinfouse = targinfo;
    end




    targs = extract_targ_array(tinfouse); 
    [ndtarg,ntarg] = size(targs);
    ntargp1 = ntarg+1;
    
    if(isfield(tinfouse,'patch_id') || isprop(tinfouse,'patch_id'))
      patch_id = tinfouse.patch_id;
    else
      patch_id = zeros(ntarg,1);
    end

    if(isfield(tinfouse,'uvs_targ') || isprop(tinfouse,'uvs_targ'))
      uvs_targ = tinfouse.uvs_targ;
    else
      uvs_targ = zeros(2,ntarg);
    end

    if(length(patch_id)~=ntarg)
      fprintf('Incorrect size of patch id in target info struct. Aborting! \n');
    end

    [n1,n2] = size(uvs_targ);
    if(n1 ~=2 && n2 ~=ntarg)
      fprintf('Incorrect size of uvs_targ array in targinfo struct. Aborting! \n');
    end


    
    iptype0 = iptype(1);
    norder0 = norders(1);
    rfac = 0.0;
    rfac0 = 0.0;
    # FORTRAN get_rfacs(int[1] norder0, int[1] iptype0, inout double[1] rfac, inout double[1] rfac0);
    

    cms = zeros(3,npatches);
    rads = zeros(npatches,1);
    # FORTRAN get_centroid_rads(int[1] npatches,int[npatches] norders,int[npp1] ixyzs,int[npatches] iptype,int[1] npts,double[n9,npts] srccoefs,inout double[n3,npatches] cms,inout double[npatches] rads);

    rad_near = rads*rfac;
    nnz = 0;
    # FORTRAN findnearmem(double[n3,npatches] cms,int[1] npatches,double[npatches] rad_near,int[1] ndtarg,double [ndtarg,ntarg] targs,int[1] ntarg,inout int[1] nnz);

    row_ptr = zeros(ntarg+1,1);
    col_ind = zeros(nnz,1);
    ntp1 = ntarg+1;
    nnzp1 = nnz+1;
    # FORTRAN findnear(double[n3,npatches] cms,int[1] npatches,double[npatches] rad_near,int[1] ndtarg,double [ndtarg,ntarg] targs, int[1] ntarg,inout int[ntp1] row_ptr,inout int[nnz] col_ind); 

    iquad = zeros(nnz+1,1);
    # FORTRAN get_iquad_rsc(int[1] npatches,int[npp1] ixyzs,int[1] npts,int[1] nnz,int[ntp1] row_ptr,int[nnz] col_ind,inout int[nnzp1] iquad);

    nquad = iquad(nnz+1)-1;
    iquadtype = 1;
    if(isfield(opts,'quadtype'))
      if(strcmpi(opts.quadtype,'ggq'))
         iquadtype = 1;
      else
        fprintf('Unsupported quadrature type, reverting to ggq\n');
        iquadtype = 1;
      end
    end

    nker = 1;
    wnear = zeros(nquad,1);

    if strcmpi(qtype, 'bc')
      # FORTRAN getnearquad_lap_s_neu(int[1] npatches, int[npatches] norders, int[npp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, double[1] eps, int[1] iquadtype, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, double[1] rfac0,int[1] nquad, inout double[nquad] wnear);
    elseif strcmpi(qtype, 'eval')
      # FORTRAN getnearquad_lap_s_neu_eval(int[1] npatches, int[npatches] norders, int[npp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, int[1] ndtarg, int[1] ntarg, double[ndtarg,ntarg] targs, int[ntarg] patch_id, double[2,ntarg] uvs_targ, double[1] eps, int[1] iquadtype, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, double[1] rfac0, int[1] nquad, inout double[nquad] wnear);
    else
      error('lap3d.neumann.GET_QUADRATURE_CORRECTION:Unsupported quadrature correction');
    end
    
    Q = [];
    Q.targinfo = targinfo;
    Q.ifcomplex = 1;
    Q.wavenumber = 0;
    Q.kernel_order = -1;
    Q.rfac = rfac;
    Q.nquad = nquad;
    Q.format = ff;
    Q.kernel_order = 0;

    if(strcmpi(ff,'rsc'))
        Q.iquad = iquad;
        Q.wnear = wnear;
        Q.row_ptr = row_ptr;
        Q.col_ind = col_ind;
    elseif(strcmpi(ff,'csc'))
        col_ptr = zeros(npatches+1,1);
        row_ind = zeros(nnz,1);
        iper = zeros(nnz,1);
        npatp1 = npatches+1;
        # FORTRAN rsc_to_csc(int[1] npatches, int[1] ntarg, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, inout int[npatp1] col_ptr, inout int[nnz] row_ind, inout int[nnz] iper); 
        Q.iquad = iquad;
        Q.iper = iper;
        Q.wnear = wnear;
        Q.col_ptr = col_ptr;
        Q.row_ind = row_ind;
    else
        spmat = conv_rsc_to_spmat(S,row_ptr,col_ind,wnear);
        Q.spmat = spmat;
    end
    
end
%
%
%
%
%-------------------------------------------------

@ +lap3d/+neumann/solver.m 
function [sigma, varargout] = solver(S, rhs, eps, opts)
%
%  lap3d.neumann.solver
%    Solve the Laplace neumann boundary value problem
%
%  Syntax
%   [sigma] = lap3d.neumann.solver(S,rhs,eps)
%   [sigma] = lap3d.neumann.solver(S,rhs,eps,opts)
%
%  Integral representation
%     pot = S_{0} [\sigma] 
%
%  S_{0}: Laplace single layer potential
%  
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * rhs: boundary data 
%    * eps: precision requested
%    * opts: options struct
%        opts.nonsmoothonly - use smooth quadrature rule for evaluating
%           layer potential (false)
%        opts.eps_gmres - tolerance to which linear system is to be
%           solved (eps_gmres = eps)
%        opts.maxit - maximum number of gmres iterations (200)
%        opts.ifout - whether to solve interior problem or not (1)
%        opts.quadrature_correction - precomputed quadrature correction ([])
%        
%
%  Output arguemnts:
%    * sigma: layer potential density
%    
%
    
    if(nargin < 4) 
      opts = [];
    end

    nonsmoothonly = false;
    if(isfield(opts,'nonsmoothonly'))
      nonsmoothonly = opts.nonsmoothonly;
    end

    eps_gmres = eps;
    if(isfield(opts,'eps_gmres'))
      eps_gmres = opts.eps_gmres;
    end

    maxit = 200;
    if(isfield(opts,'maxit'))
      maxit = opts.maxit;
    end

    ifout = 1;
    if(isfield(opts,'ifout'))
      ifout = opts.ifout;
    end

% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    targinfo = [];
    targinfo.r = S.r;
    targinfo.du = S.du;
    targinfo.dv = S.dv;
    targinfo.n = S.n;
    patch_id  = zeros(npts,1);
    uvs_targ = zeros(2,npts);
    # FORTRAN get_patch_id_uvs(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, inout int[npts] patch_id, inout double[2,npts] uvs_targ);
    targinfo.patch_id = patch_id;
    targinfo.uvs_targ = uvs_targ;

    ff = 'rsc';

    nptsp1 = npts+1;

% Compute quadrature corrections    
    if(~nonsmoothonly)

      if isfield(opts, 'quadrature_correction')
         Q = opts.quadrature_correction;
      else
        opts_quad = [];
        opts_quad.format = 'rsc';
        opts_quad.rep = 'bc';
%
%  For now Q is going to be a struct with 'quad_format', 
%  'nkernels', 'pde', 'bc', 'kernel', 'ker_order',
%  and either, 'wnear', 'row_ind', 'col_ptr', or
%  with 'spmat' as a sparse matrix or a cell array of wnear/spmat
%  if nkernel is >1
%

        [Q] = lap3d.neumann.get_quadrature_correction(S,eps,targinfo,opts_quad);
      end
    else
      opts_qcorr = [];
      opts_qcorr.type = 'double';
      opts_qcorr.nker = 1;
      Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
    end
    nnz = length(Q.col_ind);
    nquad = Q.iquad(end)-1;
    nnzp1 = nnz+1; 

    [novers] = get_oversampling_parameters(S,Q,eps);
    Sover = oversample(S,novers);


% Extract oversampled arrays

    [srcover,~,~,ixyzso,~,wover] = extract_arrays(Sover);
    nptso = Sover.npts; 

% Extract quadrature arrays
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    iquad = Q.iquad;
    wnear = Q.wnear;


    sigma = zeros(npts,1);
    niter = 0;
    errs = zeros(maxit+1,1);
    maxitp1 = maxit + 1;
    rres = 0;
    nker = 1;


% Call the layer potential evaluator
    # FORTRAN lap_s_neu_solver_guru(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, double[1] eps, int[1] maxit, int[1] ifout, double[npts] rhs, int[1] nnz, int[nptsp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, int[1] nquad, int[1] nker, double[nquad] wnear, int[npatches] novers, int[1] nptso, int[npatp1] ixyzso, double[12,nptso] srcover, double[nptso] wover, double[1] eps_gmres, inout int[1] niter, inout double[maxitp1] errs, inout double[1] rres, inout double[npts] sigma);

    errs = errs(1:niter);
    varargout{1} = errs;
    varargout{2} = rres;
    varargout{3} = Q;
end    
%
%

%-------------------------------------------------
%
%%
%%   Helmholtz dirichlet routines
%
%
%-------------------------------------------------

@ +helm3d/+dirichlet/eval.m 
function p = eval(S,sigma,targinfo,eps,zk,rep_pars,varargin)
%
%  helm3d.dirichlet.eval
%    Evaluates the helmholtz dirichlet layer potential at a collection 
%    of targets
%
%  Syntax
%   pot = helm3d.dirichlet.eval(S,sigma,targinfo,eps,zk,rep_pars)
%   pot = helm3d.dirichlet.eval(S,sigma,targinfo,eps,zk,rep_pars,opts)
%
%  Integral representation
%     pot = \alpha S_{k} [\sigma] + \beta D_{k} [\sigma]
%
%  S_{k}, D_{k}: helmholtz single and double layer potential
%  
%  \alpha, beta = rep_pars(1:2)
%  k = zk
%
%  Note: for targets on surface, only principal value part of the
%    layer potential is returned
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * sigma: layer potential density
%    * targinfo: target info (optional)
%       targinfo.r = (3,nt) target locations
%       targinfo.patch_id (nt,) patch id of target, = -1, if target
%          is off-surface (optional)
%       targinfo.uvs_targ (2,nt) local uv ccordinates of target on
%          patch if on-surface (optional)
%    * eps: precision requested
%    * zk: wave number
%    * rep_pars: kernel parameters
%        zpars(1) - single layer strength
%        zpars(2) - double layer strength
%    * opts: options struct
%        opts.nonsmoothonly - use smooth quadrature rule for evaluating
%           layer potential (false)
%        opts.precomp_quadrature: precomputed quadrature corrections struct 
%           currently only supports quadrature corrections
%           computed in rsc format 
%    

    if(nargin < 7) 
      opts = [];
    else
      opts = varargin{1};
    end

    nonsmoothonly = false;
    if(isfield(opts,'nonsmoothonly'))
      nonsmoothonly = opts.nonsmoothonly;
    end

    isprecompq = false;
    if isfield(opts, 'precomp_quadrature')
      isprecompq = true;
      Q = opts.precomp_quadrature;
    end
    
    if(isprecompq)
      if ~(strcmpi(Q.format,'rsc'))
        fprintf('Invalid precomputed quadrature format\n');
        fprintf('Ignoring quadrature corrections\n');
        opts_qcorr = [];
        opts_qcorr.type = 'complex';
        Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
      end
    end


% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    ff = 'rsc';

    [targs] = extract_targ_array(targinfo);
    [ndtarg,ntarg] = size(targs);
    ntargp1 = ntarg+1;

% Compute quadrature corrections   
    if ~isprecompq
      if ~nonsmoothonly
        opts_quad = [];
        opts_quad.format = 'rsc';
%
%  For now Q is going to be a struct with 'quad_format', 
%  'nkernels', 'pde', 'bc', 'kernel', 'ker_order',
%  and either, 'wnear', 'row_ind', 'col_ptr', or
%  with 'spmat' as a sparse matrix or a cell array of wnear/spmat
%  if nkernel is >1
%

        [Q] = helm3d.dirichlet.get_quadrature_correction(S,eps,zk,rep_pars,targinfo,opts_quad);
      else
        opts_qcorr = [];
        opts_qcorr.type = 'complex';
        Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
      end
    end
    nquad = Q.iquad(end)-1;
    nnz = length(Q.col_ind);
    nnzp1 = nnz+1; 

    [novers] = get_oversampling_parameters(S,Q,eps);
    Sover = oversample(S,novers);


% Extract oversampled arrays

    [srcover,~,~,ixyzso,~,wover] = extract_arrays(Sover);
    nptso = Sover.npts; 

% Extract quadrature arrays
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    iquad = Q.iquad;
    wnear = Q.wnear;

    p = complex(zeros(ntarg,1));

    zpars = complex(zeros(3,1));
    zpars(1) = zk;
    zpars(2) = rep_pars(1);
    zpars(3) = rep_pars(2);

    ndd = 0;
    dpars = [];
    ndz = 3;
    ndi = 0;
    ipars = [];
    nker = 1;
    lwork = 0;
    work = [];
    ndim = 1;
    idensflag = 0;
    ipotflag = 0;
    ndim_p = 1;
% Call the layer potential evaluator
    # FORTRAN helm_comb_dir_eval_addsub(int[1] npatches,int[npatches] norders, int[npatp1] ixyzs,int[npatches] iptype, int[1] npts,double[n9,npts] srccoefs,double[n12,npts] srcvals,int[1] ndtarg, int[1] ntarg, double[ndtarg,ntarg] targs, double[1] eps,int[1] ndd, double[ndd] dpars, int[1] ndz, dcomplex[ndz] zpars, int[1] ndi, int[ndi] ipars, int[1] nnz, int[ntargp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, int[1] nquad,int[1] nker,dcomplex[nquad] wnear,  int[npatches] novers, int[1] nptso, int[npatp1] ixyzso,double[12,nptso] srcover, double[nptso] wover, int[1] lwork, double[lwork] work, int[1] idensflag, int[1] ndim, dcomplex[npts] sigma, int[1] ipotflag, int[1] ndim_p, inout dcomplex[ntarg] p);   
end    
%
%
%
%----------------------------------
%
@ +helm3d/+dirichlet/get_quadrature_correction.m 
function Q = get_quadrature_correction(S, eps, zk, rep_pars, targinfo, opts)
%
%  helm3d.dirichlet.get_quadrature_correction
%    This subroutine returns the near quadrature correction
%    for the combined field representation with density supported
%    on the surface S, and targets given by targinfo 
%    as a sparse matrix/rsc format 
%
%  Syntax
%   Q = helm3d.dirichlet.get_quadrature_correction(S,eps,zk,rep_pars)
%   Q = helm3d.dirichlet.get_quadrature_correction(S,eps,zk,rep_pars,targinfo)
%   Q = helm3d.dirichlet.get_quadrature_correction(S,eps,zk,rep_pars,targinfo,opts)
%
%  Integral representation
%     pot = \alpha S_{k} [\sigma] + \beta D_{k} [\sigma]
%
%  S_{k}, D_{k}: helmholtz single and double layer potential
%  
%  \alpha, beta = rep_pars(1:2)
%  k = zk
%
%  Note: for targets on surface, only principal value part of the
%    layer potential is returned
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * eps: precision requested
%    * zk: wave number
%    * rep_pars: kernel parameters
%        rep_pars(1) - single layer strength
%        rep_pars(2) - double layer strength
%    * targinfo: target info (optional)
%       targinfo.r = (3,nt) target locations
%       targinfo.du = u tangential derivative info
%       targinfo.dv = v tangential derivative info
%       targinfo.n = normal info
%       targinfo.patch_id (nt,) patch id of target, = -1, if target
%          is off-surface (optional)
%       targinfo.uvs_targ (2,nt) local uv ccordinates of target on
%          patch if on-surface (optional)
%    * opts: options struct
%        opts.format - Storage format for sparse matrices
%           'rsc' - row sparse compressed format
%           'csc' - column sparse compressed format
%           'sparse' - sparse matrix format
%        opts.quadtype - quadrature type, currently only 'ggq' supported
%

    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;
    npp1 = npatches+1;
    n3 = 3;


    if nargin < 5
      targinfo = [];
      targinfo.r = S.r;
      targinfo.du = S.du;
      targinfo.dv = S.dv;
      targinfo.n = S.n;
      targinfo.patch_id = S.patch_id;
      targinfo.uvs_targ = S.uvs_targ;
      opts = [];
    end

    if nargin < 6
      opts = [];
    end

    ff = 'rsc';
    if(isfield(opts,'format'))
       ff = opts.format;
    end

    if(~(strcmpi(ff,'rsc') || strcmpi(ff,'csc') || strcmpi(ff,'sparse')))
       fprintf('invalid quadrature format, reverting to rsc format\n');
       ff = 'rsc';
    end


    targs = extract_targ_array(targinfo); 
    [ndtarg,ntarg] = size(targs);
    ntargp1 = ntarg+1;
    
    if(isfield(targinfo,'patch_id') || isprop(targinfo,'patch_id'))
      patch_id = targinfo.patch_id;
    else
      patch_id = zeros(ntarg,1);
    end

    if(isfield(targinfo,'uvs_targ') || isprop(targinfo,'uvs_targ'))
      uvs_targ = targinfo.uvs_targ;
    else
      uvs_targ = zeros(2,ntarg);
    end

    if(length(patch_id)~=ntarg)
      fprintf('Incorrect size of patch id in target info struct. Aborting! \n');
    end

    [n1,n2] = size(uvs_targ);
    if(n1 ~=2 && n2 ~=ntarg)
      fprintf('Incorrect size of uvs_targ array in targinfo struct. Aborting! \n');
    end


    
    iptype0 = iptype(1);
    norder0 = norders(1);
    rfac = 0.0;
    rfac0 = 0.0;
    # FORTRAN get_rfacs(int[1] norder0, int[1] iptype0, inout double[1] rfac, inout double[1] rfac0);
    

    cms = zeros(3,npatches);
    rads = zeros(npatches,1);
    # FORTRAN get_centroid_rads(int[1] npatches,int[npatches] norders,int[npp1] ixyzs,int[npatches] iptype,int[1] npts,double[n9,npts] srccoefs,inout double[n3,npatches] cms,inout double[npatches] rads);

    rad_near = rads*rfac;
    nnz = 0;
    # FORTRAN findnearmem(double[n3,npatches] cms,int[1] npatches,double[npatches] rad_near,int[1] ndtarg,double [ndtarg,ntarg] targs,int[1] ntarg,inout int[1] nnz);

    row_ptr = zeros(ntarg+1,1);
    col_ind = zeros(nnz,1);
    ntp1 = ntarg+1;
    nnzp1 = nnz+1;
    # FORTRAN findnear(double[n3,npatches] cms,int[1] npatches,double[npatches] rad_near,int[1] ndtarg,double [ndtarg,ntarg] targs, int[1] ntarg,inout int[ntp1] row_ptr,inout int[nnz] col_ind); 

    iquad = zeros(nnz+1,1);
    # FORTRAN get_iquad_rsc(int[1] npatches,int[npp1] ixyzs,int[1] npts,int[1] nnz,int[ntp1] row_ptr,int[nnz] col_ind,inout int[nnzp1] iquad);

    nquad = iquad(nnz+1)-1;
    wnear = complex(zeros(nquad,1));
    iquadtype = 1;
    if(isfield(opts,'quadtype'))
      if(strcmpi(opts.quadtype,'ggq'))
         iquadtype = 1;
      else
        fprintf('Unsupported quadrature type, reverting to ggq\n');
        iquadtype = 1;
      end
    end

    zpars = complex(zeros(3,1));
    zpars(1) = zk;
    zpars(2) = rep_pars(1);
    zpars(3) = rep_pars(2);
    # FORTRAN getnearquad_helm_comb_dir_eval(int[1] npatches,int[npatches] norders,int[npp1] ixyzs,int[npatches] iptype,int[1] npts,double[n9,npts] srccoefs,double[n12,npts] srcvals,int[1] ndtarg,int[1] ntarg,double[ndtarg,ntarg] targs, int[ntarg] patch_id, double[2,ntarg] uvs_targ,double[1] eps,dcomplex[3] zpars,int[1] iquadtype,int[1] nnz,int[ntp1] row_ptr,int[nnz] col_ind,int[nnzp1] iquad,double[1] rfac0,int[1] nquad,inout dcomplex[nquad] wnear);
    
    Q = [];
    Q.targinfo = targinfo;
    Q.ifcomplex = 1;
    Q.wavenumber = zpars(1);
    Q.kernel_order = -1;
    Q.rfac = rfac;
    Q.nquad = nquad;
    Q.format = ff;
    

    if(abs(zpars(3)) > 1e-16)
        Q.kernel_order = 0;
    end

    if(strcmpi(ff,'rsc'))
        Q.iquad = iquad;
        Q.wnear = wnear;
        Q.row_ptr = row_ptr;
        Q.col_ind = col_ind;
    elseif(strcmpi(ff,'csc'))
        col_ptr = zeros(npatches+1,1);
        row_ind = zeros(nnz,1);
        iper = zeros(nnz,1);
        npatp1 = npatches+1;
        # FORTRAN rsc_to_csc(int[1] npatches, int[1] ntarg, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, inout int[npatp1] col_ptr, inout int[nnz] row_ind, inout int[nnz] iper); 
        Q.iquad = iquad;
        Q.iper = iper;
        Q.wnear = wnear;
        Q.col_ptr = col_ptr;
        Q.row_ind = row_ind;
    else
        spmat = conv_rsc_to_spmat(S,row_ptr,col_ind,wnear);
        Q.spmat = spmat;
    end
    
end
%
%
%
%
%-------------------------------------------------

@ +helm3d/+dirichlet/solver.m 
function [sigma,varargout] = solver(S, rhs, eps, zk, rep_pars, opts)
%
%  helm3d.dirichlet.solver
%    Solve the helmholtz dirichlet boundary value problem
%
%  Syntax
%   sigma = helm3d.dirichlet.solver(S,sigma,eps,zk,rep_pars)
%   sigma = helm3d.dirichlet.solver(S,sigma,eps,zk,rep_pars,opts)
%
%  Integral representation
%     pot = \alpha S_{k} [\sigma] + \beta D_{k} [\sigma]
%
%  S_{k}, D_{k}: helmholtz single and double layer potential
%  
%  \alpha, beta = rep_pars(1:2)
%  k = zk
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * rhs: boundary data 
%    * eps: precision requested
%    * zk: wave number
%    * rep_pars: kernel parameters
%        zpars(1) - single layer strength
%        zpars(2) - double layer strength
%    * opts: options struct
%        opts.nonsmoothonly - use smooth quadrature rule for evaluating
%           layer potential (false)
%        opts.eps_gmres - tolerance to which linear system is to be
%           solved (eps_gmres = eps)
%        opts.maxit - maximum number of gmres iterations (200)
%        opts.ifout - whether to solve interior problem or not (1)
%        opts.quadrature_correction - precomputed quadrature correction ([])
%        
%
%  Output arguemnts:
%    * sigma: layer potential density
%    
%
    
    if(nargin < 6) 
      opts = [];
    end

    nonsmoothonly = false;
    if(isfield(opts,'nonsmoothonly'))
      nonsmoothonly = opts.nonsmoothonly;
    end

    eps_gmres = eps;
    if(isfield(opts,'eps_gmres'))
      eps_gmres = opts.eps_gmres;
    end

    maxit = 200;
    if(isfield(opts,'maxit'))
      maxit = opts.maxit;
    end

    ifout = 1;
    if(isfield(opts,'ifout'))
      ifout = opts.ifout;
    end

% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    targinfo = [];
    targinfo.r = S.r;
    targinfo.du = S.du;
    targinfo.dv = S.dv;
    targinfo.n = S.n;
    patch_id  = zeros(npts,1);
    uvs_targ = zeros(2,npts);
    # FORTRAN get_patch_id_uvs(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, inout int[npts] patch_id, inout double[2,npts] uvs_targ);
    targinfo.patch_id = patch_id;
    targinfo.uvs_targ = uvs_targ;

    ff = 'rsc';

    nptsp1 = npts+1;

% Compute quadrature corrections    
    if(~nonsmoothonly)

      if isfield(opts, 'quadrature_correction')
         Q = opts.quadrature_correction;
      else
        opts_quad = [];
        opts_quad.format = 'rsc';
%
%  For now Q is going to be a struct with 'quad_format', 
%  'nkernels', 'pde', 'bc', 'kernel', 'ker_order',
%  and either, 'wnear', 'row_ind', 'col_ptr', or
%  with 'spmat' as a sparse matrix or a cell array of wnear/spmat
%  if nkernel is >1
%

        [Q] = helm3d.dirichlet.get_quadrature_correction(S,eps,zk,rep_pars,targinfo,opts_quad);
      end
    else
      opts_qcorr = [];
      opts_qcorr.type = 'complex';
      Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
    end
    nnz = length(Q.col_ind);
    nquad = Q.iquad(end)-1;
    nnzp1 = nnz+1; 

    [novers] = get_oversampling_parameters(S,Q,eps);
    Sover = oversample(S,novers);


% Extract oversampled arrays

    [srcover,~,~,ixyzso,~,wover] = extract_arrays(Sover);
    nptso = Sover.npts; 

% Extract quadrature arrays
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    iquad = Q.iquad;
    wnear = Q.wnear;


    sigma = complex(zeros(npts,1));
    niter = 0;
    errs = zeros(maxit+1,1);
    maxitp1 = maxit + 1;
    rres = 0;
    nker = 1;

    zpars = complex(zeros(3,1));
    zpars(1) = zk;
    zpars(2) = rep_pars(1);
    zpars(3) = rep_pars(2);

% Call the layer potential evaluator
    # FORTRAN helm_comb_dir_solver_guru(int[1] npatches,int[npatches] norders, int[npatp1] ixyzs,int[npatches] iptype, int[1] npts,double[n9,npts] srccoefs,double[n12,npts] srcvals, double[1] eps, dcomplex[3] zpars, int[1] maxit, int[1] ifout, dcomplex[npts] rhs, int[1] nnz, int[nptsp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, int[1] nquad, int[1] nker, dcomplex[nquad] wnear, int[npatches] novers, int[1] nptso, int[npatp1] ixyzso, double[12,nptso] srcover, double[nptso] wover, double[1] eps_gmres, inout int[1] niter, inout double[maxitp1] errs, inout double[1] rres, inout dcomplex[npts] sigma);  

    errs = errs(1:niter);
    varargout{1} = errs;
    varargout{2} = rres;
    varargout{3} = Q;
end    
%
%
%
%
%


%-------------------------------------------------
%
%%
%%   Helmholtz neumann routines
%
%
%-------------------------------------------------

@ +helm3d/+neumann/eval.m 
function p = eval(S,densities,targinfo,eps,zk,alpha,varargin)
%
%  helm3d.neumann.eval
%    Evaluates the helmholtz neumann layer potential at a collection 
%    of targets
%
%  Syntax
%   pot = helm3d.neumann.eval(S,densities,targinfo,eps,zk,alpha)
%   pot = helm3d.neumann.eval(S,densities,targinfo,eps,zk,alpha,opts)
%
%  Integral representation
%     pot = S_{k} [\sigma] + i \alpha D_{k} S_{i|k|}[\sigma]
%
%  S_{k}, D_{k}: helmholtz single and double layer potential
%  
%  densities(2,1:npts) for rpcomb, with densities(1,:) = sigma, 
%  and densities(2,:) = S_{i|k|} sigma
%
%  Note: for targets on surface, only principal value part of the
%    layer potential is returned
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * densities: layer potential densities
%    * targinfo: target info 
%       targinfo.r = (3,nt) target locations
%       targinfo.n = normal info
%       targinfo.patch_id (nt,) patch id of target, = -1, if target
%          is off-surface (optional)
%       targinfo.uvs_targ (2,nt) local uv ccordinates of target on
%          patch if on-surface (optional)
%    * eps: precision requested
%    * zk: wave number (k)
%    * alpha: alpha above
%    * opts: options struct
%        opts.nonsmoothonly - use smooth quadrature rule for evaluating
%           layer potential (false)
%        opts.precomp_quadrature: precomputed quadrature corrections struct 
%           currently only supports quadrature corrections
%           computed in rsc format 
%    

    if(nargin < 7) 
      opts = [];
    else
      opts = varargin{1};
    end

    nonsmoothonly = false;
    if(isfield(opts,'nonsmoothonly'))
      nonsmoothonly = opts.nonsmoothonly;
    end

    isprecompq = false;
    if isfield(opts, 'precomp_quadrature')
      isprecompq = true;
      Q = opts.precomp_quadrature;
    end
    
    if(isprecompq)
      if ~(strcmpi(Q.format,'rsc'))
        fprintf('Invalid precomputed quadrature format\n');
        fprintf('Ignoring quadrature corrections\n');
        opts_qcorr = [];
        opts_qcorr.type = 'complex';
        Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
      end
    end


% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    ff = 'rsc';

    [targs] = extract_targ_array(targinfo);
    [ndtarg,ntarg] = size(targs);
    ntargp1 = ntarg+1;

% Compute quadrature corrections   
    if ~isprecompq
      if ~nonsmoothonly
        opts_quad = [];
        opts_quad.format = 'rsc';
        opts_quad.rep = 'rpcomb-eval';
%
%  For now Q is going to be a struct with 'quad_format', 
%  'nkernels', 'pde', 'bc', 'kernel', 'ker_order',
%  and either, 'wnear', 'row_ind', 'col_ptr', or
%  with 'spmat' as a sparse matrix or a cell array of wnear/spmat
%  if nkernel is >1
%

        [Q] = helm3d.neumann.get_quadrature_correction(S,eps,zk,alpha,targinfo,opts_quad);
      else
        opts_qcorr = [];
        opts_qcorr.type = 'complex';
        Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
      end
    end
    nquad = Q.iquad(end)-1;
    nnz = length(Q.col_ind);
    nnzp1 = nnz+1; 

    [novers] = get_oversampling_parameters(S,Q,eps);
    Sover = oversample(S,novers);


% Extract oversampled arrays

    [srcover,~,~,ixyzso,~,wover] = extract_arrays(Sover);
    nptso = Sover.npts; 

% Extract quadrature arrays
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    iquad = Q.iquad;
    wnear = Q.wnear;

    p = complex(zeros(ntarg,1));

    ndd = 0;
    dpars = [];
    ndz = 2;
    zpars = complex(zeros(2,1));
    zpars(1) = zk;
    zpars(2) = alpha;
    ndi = 0;
    ipars = [];
    nker = 2;
    lwork = 0;
    work = [];
    ndim_s = 2;
    ndim_p = 1;
    idensflag = 1;
    ipotflag = 1;
% Call the layer potential evaluator
    # FORTRAN helm_rpcomb_eval_addsub(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, int[1] ndtarg, int[1] ntarg, double[ndtarg,ntarg] targs, double[1] eps, int[1] ndd, double[ndd] dpars, int[1] ndz, dcomplex[ndz] zpars, int[1] ndi, int[ndi] ipars, int[1] nnz, int[ntargp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, int[1] nquad, int[1] nker, dcomplex[nker,nquad] wnear,  int[npatches] novers, int[1] nptso, int[npatp1] ixyzso, double[12,nptso] srcover, double[nptso] wover, int[1] lwork, double[lwork] work, int[1] idensflag, int[1] ndim_s, dcomplex[2,npts] densities, int[1] ipotflag, int[1] ndim_p, inout dcomplex[ntarg] p);   
end    
%
%
%
%----------------------------------
%
@ +helm3d/+neumann/get_quadrature_correction.m 
function Q = get_quadrature_correction(S, eps, zk, alpha, targinfo, opts)
%
%  helm3d.neumann.get_quadrature_correction
%    This subroutine returns the near quadrature correction
%    for the combined field representation with density supported
%    on the surface S, and targets given by targinfo 
%    as a sparse matrix/rsc format 
%
%  Syntax
%   Q = helm3d.neumann.get_quadrature_correction(S,eps,zk,alpha)
%   Q = helm3d.neumann.get_quadrature_correction(S,eps,zk,alpha,targinfo)
%   Q = helm3d.neumann.get_quadrature_correction(S,eps,zk,alpha,targinfo,opts)
%
%  Integral representation
%     pot = S_{k} [\sigma] + 1i \alpha D_{k} S_{i|k|} [\sigma]
%
%  S_{k}, D_{k}: helmholtz single and double layer potential
%  
%
%  Note: for targets on surface, only principal value part of the
%    layer potential is returned
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * eps: precision requested
%    * zk: wave number
%    * alpha: alpha above
%    * targinfo: target info (optional)
%       targinfo.r = (3,nt) target locations
%       targinfo.du = u tangential derivative info
%       targinfo.dv = v tangential derivative info
%       targinfo.n = normal info
%       targinfo.patch_id (nt,) patch id of target, = -1, if target
%          is off-surface (optional)
%       targinfo.uvs_targ (2,nt) local uv ccordinates of target on
%          patch if on-surface (optional)
%    * opts: options struct
%        opts.format - Storage format for sparse matrices
%           'rsc' - row sparse compressed format
%           'csc' - column sparse compressed format
%           'sparse' - sparse matrix format
%        opts.quadtype - quadrature type, currently only 'ggq' supported
%        opts.rep - whether to compute correction for on surface
%                   integral equation or post-processing
%                   'rpcomb-bc' - on surface integral equation. If option
%                   is 'rpcomb-bc' then targinfo is ignored
%                   'rpcomb-eval' - post-processing
%

    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;
    npp1 = npatches+1;
    nsp1 = npts + 1;
    n3 = 3;

    if nargin < 4
      targinfo = [];
      targinfo.r = S.r;
      targinfo.du = S.du;
      targinfo.dv = S.dv;
      targinfo.n = S.n;
      targinfo.patch_id = S.patch_id;
      targinfo.uvs_targ = S.uvs_targ;
      opts = [];
    end

    qtype = 'rpcomb-bc';

    if nargin < 5
      opts = [];
    end

    if isfield(opts, 'rep')
      qtype = opts.rep;
    end

    ff = 'rsc';
    if(isfield(opts,'format'))
       ff = opts.format;
    end

    if(~(strcmpi(ff,'rsc') || strcmpi(ff,'csc') || strcmpi(ff,'sparse')))
       fprintf('invalid quadrature format, reverting to rsc format\n');
       ff = 'rsc';
    end

    tinfouse = [];
    if strcmpi(qtype, 'rpcomb-bc')
      tinfouse.r = S.r;
      tinfouse.du = S.du;
      tinfouse.dv = S.dv;
      tinfouse.n = S.n;
      tinfouse.patch_id = S.patch_id;
      tinfouse.uvs_targ = S.uvs_targ;
    else
      tinfouse = targinfo;
    end




    targs = extract_targ_array(tinfouse); 
    [ndtarg,ntarg] = size(targs);
    ntargp1 = ntarg+1;
    
    if(isfield(tinfouse,'patch_id') || isprop(tinfouse,'patch_id'))
      patch_id = tinfouse.patch_id;
    else
      patch_id = zeros(ntarg,1);
    end

    if(isfield(tinfouse,'uvs_targ') || isprop(tinfouse,'uvs_targ'))
      uvs_targ = tinfouse.uvs_targ;
    else
      uvs_targ = zeros(2,ntarg);
    end

    if(length(patch_id)~=ntarg)
      fprintf('Incorrect size of patch id in target info struct. Aborting! \n');
    end

    [n1,n2] = size(uvs_targ);
    if(n1 ~=2 && n2 ~=ntarg)
      fprintf('Incorrect size of uvs_targ array in targinfo struct. Aborting! \n');
    end


    
    iptype0 = iptype(1);
    norder0 = norders(1);
    rfac = 0.0;
    rfac0 = 0.0;
    # FORTRAN get_rfacs(int[1] norder0, int[1] iptype0, inout double[1] rfac, inout double[1] rfac0);
    

    cms = zeros(3,npatches);
    rads = zeros(npatches,1);
    # FORTRAN get_centroid_rads(int[1] npatches,int[npatches] norders,int[npp1] ixyzs,int[npatches] iptype,int[1] npts,double[n9,npts] srccoefs,inout double[n3,npatches] cms,inout double[npatches] rads);

    rad_near = rads*rfac;
    nnz = 0;
    # FORTRAN findnearmem(double[n3,npatches] cms,int[1] npatches,double[npatches] rad_near,int[1] ndtarg,double [ndtarg,ntarg] targs,int[1] ntarg,inout int[1] nnz);

    row_ptr = zeros(ntarg+1,1);
    col_ind = zeros(nnz,1);
    ntp1 = ntarg+1;
    nnzp1 = nnz+1;
    # FORTRAN findnear(double[n3,npatches] cms,int[1] npatches,double[npatches] rad_near,int[1] ndtarg,double [ndtarg,ntarg] targs, int[1] ntarg,inout int[ntp1] row_ptr,inout int[nnz] col_ind); 

    iquad = zeros(nnz+1,1);
    # FORTRAN get_iquad_rsc(int[1] npatches,int[npp1] ixyzs,int[1] npts,int[1] nnz,int[ntp1] row_ptr,int[nnz] col_ind,inout int[nnzp1] iquad);

    nquad = iquad(nnz+1)-1;
    iquadtype = 1;
    if(isfield(opts,'quadtype'))
      if(strcmpi(opts.quadtype,'ggq'))
         iquadtype = 1;
      else
        fprintf('Unsupported quadrature type, reverting to ggq\n');
        iquadtype = 1;
      end
    end

    zpars = complex(zeros(2,1));
    zpars(1) = zk;
    zpars(2) = alpha;
    zkuse = complex(zk);

    if strcmpi(qtype, 'rpcomb-bc')
      nker = 4;
      wnear = complex(zeros(nker,nquad));
      # FORTRAN getnearquad_helm_rpcomb_neu(int[1] npatches, int[npatches] norders, int[npp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, double[1] eps, dcomplex[2] zpars, int[1] iquadtype, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, double[1] rfac0,int[1] nquad, inout dcomplex[nker,nquad] wnear);
    elseif strcmpi(qtype, 'rpcomb-eval')
      nker = 2;
      wnear = complex(zeros(nker,nquad));
      # FORTRAN getnearquad_helm_rpcomb_eval(int[1] npatches, int[npatches] norders, int[npp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, int[1] ndtarg, int[1] ntarg, double[ndtarg,ntarg] targs, int[ntarg] patch_id, double[2,ntarg] uvs_targ, double[1] eps, dcomplex[1] zkuse, int[1] iquadtype, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, double[1] rfac0, int[1] nquad, inout dcomplex[nker,nquad] wnear);
    else
      error('HELM3D.neumann.GET_QUADRATURE_CORRECTION:Unsupported quadrature correction');
    end
    
    Q = [];
    Q.targinfo = targinfo;
    Q.ifcomplex = 1;
    Q.wavenumber = zk;
    Q.kernel_order = -1;
    Q.rfac = rfac;
    Q.nquad = nquad;
    Q.format = ff;
    Q.kernel_order = 0;

    if(strcmpi(ff,'rsc'))
        Q.iquad = iquad;
        Q.wnear = wnear;
        Q.row_ptr = row_ptr;
        Q.col_ind = col_ind;
    elseif(strcmpi(ff,'csc'))
        col_ptr = zeros(npatches+1,1);
        row_ind = zeros(nnz,1);
        iper = zeros(nnz,1);
        npatp1 = npatches+1;
        # FORTRAN rsc_to_csc(int[1] npatches, int[1] ntarg, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, inout int[npatp1] col_ptr, inout int[nnz] row_ind, inout int[nnz] iper); 
        Q.iquad = iquad;
        Q.iper = iper;
        Q.wnear = wnear;
        Q.col_ptr = col_ptr;
        Q.row_ind = row_ind;
    else
        spmat = conv_rsc_to_spmat(S,row_ptr,col_ind,wnear);
        Q.spmat = spmat;
    end
    
end
%
%
%
%
%-------------------------------------------------

@ +helm3d/+neumann/solver.m 
function [densities, varargout] = solver(S, rhs, eps, zk, alpha, opts)
%
%  helm3d.neumann.solver
%    Solve the helmholtz neumann boundary value problem
%
%  Syntax
%   [densities] = helm3d.neumann.solver(S,rhs,eps,zk,alpha)
%   [densities] = helm3d.neumann.solver(S,rhs,eps,zk,alpha,opts)
%
%  Integral representation
%     pot = S_{k} [\sigma] + i \alpha D_{k}S_{i|k|} [\sigma]
%
%  S_{k}, D_{k}: helmholtz single and double layer potential
%  
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * rhs: boundary data 
%    * eps: precision requested
%    * zk: wave number
%    * alpha: alpha above
%    * opts: options struct
%        opts.nonsmoothonly - use smooth quadrature rule for evaluating
%           layer potential (false)
%        opts.eps_gmres - tolerance to which linear system is to be
%           solved (eps_gmres = eps)
%        opts.maxit - maximum number of gmres iterations (200)
%        opts.ifout - whether to solve interior problem or not (1)
%        opts.quadrature_correction - precomputed quadrature correction ([])
%        
%
%  Output arguemnts:
%    * densities: solution to integral equation
%         densities(1,:) = sigma
%         densities(2,:) = S_{i|k|} \sigma
%    
%
    
    if(nargin < 6) 
      opts = [];
    end

    nonsmoothonly = false;
    if(isfield(opts,'nonsmoothonly'))
      nonsmoothonly = opts.nonsmoothonly;
    end

    eps_gmres = eps;
    if(isfield(opts,'eps_gmres'))
      eps_gmres = opts.eps_gmres;
    end

    maxit = 200;
    if(isfield(opts,'maxit'))
      maxit = opts.maxit;
    end

    ifout = 1;
    if(isfield(opts,'ifout'))
      ifout = opts.ifout;
    end

% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    targinfo = [];
    targinfo.r = S.r;
    targinfo.du = S.du;
    targinfo.dv = S.dv;
    targinfo.n = S.n;
    patch_id  = zeros(npts,1);
    uvs_targ = zeros(2,npts);
    # FORTRAN get_patch_id_uvs(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, inout int[npts] patch_id, inout double[2,npts] uvs_targ);
    targinfo.patch_id = patch_id;
    targinfo.uvs_targ = uvs_targ;

    ff = 'rsc';

    nptsp1 = npts+1;

% Compute quadrature corrections    
    if(~nonsmoothonly)

      if isfield(opts, 'quadrature_correction')
         Q = opts.quadrature_correction;
      else
        opts_quad = [];
        opts_quad.format = 'rsc';
        opts_quad.rep = 'rpcomb-bc';
%
%  For now Q is going to be a struct with 'quad_format', 
%  'nkernels', 'pde', 'bc', 'kernel', 'ker_order',
%  and either, 'wnear', 'row_ind', 'col_ptr', or
%  with 'spmat' as a sparse matrix or a cell array of wnear/spmat
%  if nkernel is >1
%

        [Q] = helm3d.neumann.get_quadrature_correction(S,eps,zk,alpha,targinfo,opts_quad);
      end
    else
      opts_qcorr = [];
      opts_qcorr.type = 'complex';
      opts_qcorr.nker = 4;
      Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
    end
    nnz = length(Q.col_ind);
    nquad = Q.iquad(end)-1;
    nnzp1 = nnz+1; 

    [novers] = get_oversampling_parameters(S,Q,eps);
    Sover = oversample(S,novers);


% Extract oversampled arrays

    [srcover,~,~,ixyzso,~,wover] = extract_arrays(Sover);
    nptso = Sover.npts; 

% Extract quadrature arrays
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    iquad = Q.iquad;
    wnear = Q.wnear;


    sigma = complex(zeros(1,npts));
    siksigma = complex(zeros(1,npts));
    niter = 0;
    errs = zeros(maxit+1,1);
    maxitp1 = maxit + 1;
    rres = 0;
    nker = 4;

    zpars = complex(zeros(2,1));
    zpars(1) = zk;
    zpars(2) = alpha;


% Call the layer potential evaluator
    # FORTRAN helm_rpcomb_neu_solver_guru(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, double[1] eps, dcomplex[2] zpars, int[1] maxit, int[1] ifout, dcomplex[npts] rhs, int[1] nnz, int[nptsp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, int[1] nquad, int[1] nker, dcomplex[nker,nquad] wnear, int[npatches] novers, int[1] nptso, int[npatp1] ixyzso, double[12,nptso] srcover, double[nptso] wover, double[1] eps_gmres, inout int[1] niter, inout double[maxitp1] errs, inout double[1] rres, inout dcomplex[npts] sigma, inout dcomplex[npts] siksigma);  

    densities = complex(zeros(2,npts));
    densities(1,:) = sigma;
    densities(2,:) = siksigma;
    
    errs = errs(1:niter);
    varargout{1} = errs;
    varargout{2} = rres;
    varargout{3} = Q;
end    
%
%

%-------------------------------------------------
%
%%
%%   Helmholtz impedance routines
%
%
%-------------------------------------------------

@ +helm3d/+impedance/eval.m 
function p = eval(S,densities,targinfo,eps,zk,alpha,varargin)
%
%  helm3d.impedance.eval
%    Evaluates the helmholtz impedance layer potential at a collection 
%    of targets
%
%  Syntax
%   pot = helm3d.impedance.eval(S,densities,targinfo,eps,zk,alpha)
%   pot = helm3d.impedance.eval(S,densities,targinfo,eps,zk,alpha,opts)
%
%  Integral representation
%     pot = S_{k} [\sigma] + i \alpha D_{k} S_{i|k|}[\sigma]
%
%  S_{k}, D_{k}: helmholtz single and double layer potential
%  
%  densities(2,1:npts) for rpcomb, with densities(1,:) = sigma, 
%  and densities(2,:) = S_{i|k|} sigma
%
%  Note: for targets on surface, only principal value part of the
%    layer potential is returned
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * densities: layer potential densities
%    * targinfo: target info 
%       targinfo.r = (3,nt) target locations
%       targinfo.patch_id (nt,) patch id of target, = -1, if target
%          is off-surface (optional)
%       targinfo.uvs_targ (2,nt) local uv ccordinates of target on
%          patch if on-surface (optional)
%    * eps: precision requested
%    * zk: wave number
%    * alpha: alpha above
%    * opts: options struct
%        opts.nonsmoothonly - use smooth quadrature rule for evaluating
%           layer potential (false)
%        opts.precomp_quadrature: precomputed quadrature corrections struct 
%           currently only supports quadrature corrections
%           computed in rsc format 
%    

    if(nargin < 7) 
      opts = [];
    else
      opts = varargin{1};
    end

    isprecompq = false;
    if isfield(opts, 'precomp_quadrature')
      Q = opts.precomp_quadrature;
      isprecompq = true;
    end

    nonsmoothonly = false;
    if(isfield(opts,'nonsmoothonly'))
      nonsmoothonly = opts.nonsmoothonly;
    end
    
    if(isprecompq)
      if ~(strcmpi(Q.format,'rsc'))
        fprintf('Invalid precomputed quadrature format\n');
        fprintf('Ignoring quadrature corrections\n');
        opts_qcorr = [];
        opts_qcorr.type = 'complex';
        Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
      end
    end


% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    ff = 'rsc';

    [targs] = extract_targ_array(targinfo);
    [ndtarg,ntarg] = size(targs);
    ntargp1 = ntarg+1;

% Compute quadrature corrections   
    if ~isprecompq
      if ~nonsmoothonly
        opts_quad = [];
        opts_quad.format = 'rsc';
        opts_quad.rep = 'rpcomb-eval';
%
%  For now Q is going to be a struct with 'quad_format', 
%  'nkernels', 'pde', 'bc', 'kernel', 'ker_order',
%  and either, 'wnear', 'row_ind', 'col_ptr', or
%  with 'spmat' as a sparse matrix or a cell array of wnear/spmat
%  if nkernel is >1
%

        [Q] = helm3d.impedance.get_quadrature_correction(S,eps,zk,alpha,targinfo,opts_quad);
      else
        opts_qcorr = [];
        opts_qcorr.type = 'complex';
        Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
      end
    end
    nquad = Q.iquad(end)-1;
    nnz = length(Q.col_ind);
    nnzp1 = nnz+1; 

    [novers] = get_oversampling_parameters(S,Q,eps);
    Sover = oversample(S,novers);


% Extract oversampled arrays

    [srcover,~,~,ixyzso,~,wover] = extract_arrays(Sover);
    nptso = Sover.npts; 

% Extract quadrature arrays
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    iquad = Q.iquad;
    wnear = Q.wnear;

    p = complex(zeros(ntarg,1));

    ndd = 0;
    dpars = [];
    ndz = 2;
    zpars = complex(zeros(2,1));
    zpars(1) = zk;
    zpars(2) = alpha;
    ndi = 0;
    ipars = [];
    nker = 2;
    lwork = 0;
    work = [];
    ndim_s = 2;
    ndim_p = 1;
    idensflag = 1;
    ipotflag = 1;
% Call the layer potential evaluator
    # FORTRAN helm_rpcomb_eval_addsub(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, int[1] ndtarg, int[1] ntarg, double[ndtarg,ntarg] targs, double[1] eps, int[1] ndd, double[ndd] dpars, int[1] ndz, dcomplex[ndz] zpars, int[1] ndi, int[ndi] ipars, int[1] nnz, int[ntargp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, int[1] nquad, int[1] nker, dcomplex[nker,nquad] wnear,  int[npatches] novers, int[1] nptso, int[npatp1] ixyzso, double[12,nptso] srcover, double[nptso] wover, int[1] lwork, double[lwork] work, int[1] idensflag, int[1] ndim_s, dcomplex[2,npts] densities, int[1] ipotflag, int[1] ndim_p, inout dcomplex[ntarg] p);   
end    
%
%
%
%----------------------------------
%
@ +helm3d/+impedance/get_quadrature_correction.m 
function Q = get_quadrature_correction(S, eps, zk, alpha, targinfo, opts)
%
%  helm3d.impedance.get_quadrature_correction
%    This subroutine returns the near quadrature correction
%    for the combined field representation with density supported
%    on the surface S, and targets given by targinfo 
%    as a sparse matrix/rsc format 
%
%  Syntax
%   Q = helm3d.impedance.get_quadrature_correction(S,eps,zk,alpha)
%   Q = helm3d.impedance.get_quadrature_correction(S,eps,zk,alpha,targinfo)
%   Q = helm3d.impedance.get_quadrature_correction(S,eps,zk,alpha,targinfo,opts)
%
%  Integral representation
%     pot = S_{k} [\sigma] + 1i \alpha D_{k} S_{i|k|} [\sigma]
%
%  S_{k}, D_{k}: helmholtz single and double layer potential
%  
%  Note: for targets on surface, only principal value part of the
%    layer potential is returned
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * eps: precision requested
%    * zk: wave number
%    * alpha: alpha above
%    * targinfo: target info (optional)
%       targinfo.r = (3,nt) target locations
%       targinfo.du = u tangential derivative info
%       targinfo.dv = v tangential derivative info
%       targinfo.n = normal info
%       targinfo.patch_id (nt,) patch id of target, = -1, if target
%          is off-surface (optional)
%       targinfo.uvs_targ (2,nt) local uv ccordinates of target on
%          patch if on-surface (optional)
%    * opts: options struct
%        opts.format - Storage format for sparse matrices
%           'rsc' - row sparse compressed format
%           'csc' - column sparse compressed format
%           'sparse' - sparse matrix format
%        opts.quadtype - quadrature type, currently only 'ggq' supported
%        opts.rep - whether to compute correction for on surface
%                   integral equation or post-processing
%                   'rpcomb-bc' - on surface integral equation. If option
%                   is 'rpcomb-bc' then targinfo is ignored
%                   'rpcomb-eval' - post-processing
%

    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;
    npp1 = npatches+1;
    nsp1 = npts + 1;
    n3 = 3;

    if nargin < 5
      targinfo = [];
      targinfo.r = S.r;
      targinfo.du = S.du;
      targinfo.dv = S.dv;
      targinfo.n = S.n;
      targinfo.patch_id = S.patch_id;
      targinfo.uvs_targ = S.uvs_targ;
      opts = [];
    end

    qtype = 'rpcomb-bc';

    if nargin < 6
      opts = [];
    end

    if isfield(opts, 'rep')
      qtype = opts.rep;
    end

    ff = 'rsc';
    if(isfield(opts,'format'))
       ff = opts.format;
    end

    if(~(strcmpi(ff,'rsc') || strcmpi(ff,'csc') || strcmpi(ff,'sparse')))
       fprintf('invalid quadrature format, reverting to rsc format\n');
       ff = 'rsc';
    end

    tinfouse = [];
    if strcmpi(qtype, 'rpcomb-bc')
      tinfouse.r = S.r;
      tinfouse.du = S.du;
      tinfouse.dv = S.dv;
      tinfouse.n = S.n;
      tinfouse.patch_id = S.patch_id;
      tinfouse.uvs_targ = S.uvs_targ;
    else
      tinfouse = targinfo;
    end




    targs = extract_targ_array(tinfouse); 
    [ndtarg,ntarg] = size(targs);
    ntargp1 = ntarg+1;
    
    if(isfield(tinfouse,'patch_id') || isprop(tinfouse,'patch_id'))
      patch_id = tinfouse.patch_id;
    else
      patch_id = zeros(ntarg,1);
    end

    if(isfield(tinfouse,'uvs_targ') || isprop(tinfouse,'uvs_targ'))
      uvs_targ = tinfouse.uvs_targ;
    else
      uvs_targ = zeros(2,ntarg);
    end

    if(length(patch_id)~=ntarg)
      fprintf('Incorrect size of patch id in target info struct. Aborting! \n');
    end

    [n1,n2] = size(uvs_targ);
    if(n1 ~=2 && n2 ~=ntarg)
      fprintf('Incorrect size of uvs_targ array in targinfo struct. Aborting! \n');
    end


    
    iptype0 = iptype(1);
    norder0 = norders(1);
    rfac = 0.0;
    rfac0 = 0.0;
    # FORTRAN get_rfacs(int[1] norder0, int[1] iptype0, inout double[1] rfac, inout double[1] rfac0);
    

    cms = zeros(3,npatches);
    rads = zeros(npatches,1);
    # FORTRAN get_centroid_rads(int[1] npatches,int[npatches] norders,int[npp1] ixyzs,int[npatches] iptype,int[1] npts,double[n9,npts] srccoefs,inout double[n3,npatches] cms,inout double[npatches] rads);

    rad_near = rads*rfac;
    nnz = 0;
    # FORTRAN findnearmem(double[n3,npatches] cms,int[1] npatches,double[npatches] rad_near,int[1] ndtarg,double [ndtarg,ntarg] targs,int[1] ntarg,inout int[1] nnz);

    row_ptr = zeros(ntarg+1,1);
    col_ind = zeros(nnz,1);
    ntp1 = ntarg+1;
    nnzp1 = nnz+1;
    # FORTRAN findnear(double[n3,npatches] cms,int[1] npatches,double[npatches] rad_near,int[1] ndtarg,double [ndtarg,ntarg] targs, int[1] ntarg,inout int[ntp1] row_ptr,inout int[nnz] col_ind); 

    iquad = zeros(nnz+1,1);
    # FORTRAN get_iquad_rsc(int[1] npatches,int[npp1] ixyzs,int[1] npts,int[1] nnz,int[ntp1] row_ptr,int[nnz] col_ind,inout int[nnzp1] iquad);

    nquad = iquad(nnz+1)-1;
    iquadtype = 1;
    if(isfield(opts,'quadtype'))
      if(strcmpi(opts.quadtype,'ggq'))
         iquadtype = 1;
      else
        fprintf('Unsupported quadrature type, reverting to ggq\n');
        iquadtype = 1;
      end
    end

    zpars = complex(zeros(2,1));
    zpars(1) = zk;
    zpars(2) = alpha;

    zkuse = complex(zk);

    if strcmpi(qtype, 'rpcomb-bc')
      nker = 6;
      wnear = complex(zeros(nker,nquad));
      # FORTRAN getnearquad_helm_rpcomb_imp(int[1] npatches, int[npatches] norders, int[npp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, double[1] eps, dcomplex[2] zpars, int[1] iquadtype, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, double[1] rfac0,int[1] nquad, inout dcomplex[nker,nquad] wnear);
    elseif strcmpi(qtype, 'rpcomb-eval')
      nker = 2;
      wnear = complex(zeros(nker,nquad));
      # FORTRAN getnearquad_helm_rpcomb_eval(int[1] npatches, int[npatches] norders, int[npp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, int[1] ndtarg, int[1] ntarg, double[ndtarg,ntarg] targs, int[ntarg] patch_id, double[2,ntarg] uvs_targ, double[1] eps, dcomplex[1] zkuse, int[1] iquadtype, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, double[1] rfac0, int[1] nquad, inout dcomplex[nker,nquad] wnear);
    else
      error('HELM3D.IMPEDANCE.GET_QUADRATURE_CORRECTION:Unsupported quadrature correction');
    end
    
    Q = [];
    Q.targinfo = targinfo;
    Q.ifcomplex = 1;
    Q.wavenumber = zk;
    Q.kernel_order = -1;
    Q.rfac = rfac;
    Q.nquad = nquad;
    Q.format = ff;
    Q.kernel_order = 0;

    if(strcmpi(ff,'rsc'))
        Q.iquad = iquad;
        Q.wnear = wnear;
        Q.row_ptr = row_ptr;
        Q.col_ind = col_ind;
    elseif(strcmpi(ff,'csc'))
        col_ptr = zeros(npatches+1,1);
        row_ind = zeros(nnz,1);
        iper = zeros(nnz,1);
        npatp1 = npatches+1;
        # FORTRAN rsc_to_csc(int[1] npatches, int[1] ntarg, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, inout int[npatp1] col_ptr, inout int[nnz] row_ind, inout int[nnz] iper); 
        Q.iquad = iquad;
        Q.iper = iper;
        Q.wnear = wnear;
        Q.col_ptr = col_ptr;
        Q.row_ind = row_ind;
    else
        spmat = conv_rsc_to_spmat(S,row_ptr,col_ind,wnear);
        Q.spmat = spmat;
    end
    
end
%
%
%
%
%-------------------------------------------------

@ +helm3d/+impedance/solver.m 
function [densities, varargout] = solver(S, zlams, rhs, eps, zk, alpha, opts)
%
%  helm3d.impedance.solver
%    Solve the helmholtz impedance boundary value problem
%
%  Syntax
%   [densities] = helm3d.impedance.solver(S,zlams,rhs,eps,zk,alpha)
%   [densities] = helm3d.impedance.solver(S,zlams,rhs,eps,zk,alpha,opts)
%
%  Integral representation
%     pot = S_{k} [\sigma] + i\alpha D_{k}S_{i|k|} [\sigma]
%
%  S_{k}, D_{k}: helmholtz single and double layer potential
%  
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * rhs: boundary data 
%    * eps: precision requested
%    * zk: wave number
%    * alpha: alpha above
%    * opts: options struct
%        opts.nonsmoothonly - use smooth quadrature rule for evaluating
%           layer potential (false)
%        opts.eps_gmres - tolerance to which linear system is to be
%           solved (eps_gmres = eps)
%        opts.maxit - maximum number of gmres iterations (200)
%        opts.ifout - whether to solve interior problem or not (1)
%        opts.quadrature_correction - precomputed quadrature correction ([])
%        
%
%  Output arguemnts:
%    * sigma: layer potential density
%    
%
    
    if(nargin < 7) 
      opts = [];
    end

    nonsmoothonly = false;
    if(isfield(opts,'nonsmoothonly'))
      nonsmoothonly = opts.nonsmoothonly;
    end

    eps_gmres = eps;
    if(isfield(opts,'eps_gmres'))
      eps_gmres = opts.eps_gmres;
    end

    maxit = 200;
    if(isfield(opts,'maxit'))
      maxit = opts.maxit;
    end

    ifout = 1;
    if(isfield(opts,'ifout'))
      ifout = opts.ifout;
    end

% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    targinfo = [];
    targinfo.r = S.r;
    targinfo.du = S.du;
    targinfo.dv = S.dv;
    targinfo.n = S.n;
    patch_id  = zeros(npts,1);
    uvs_targ = zeros(2,npts);
    # FORTRAN get_patch_id_uvs(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, inout int[npts] patch_id, inout double[2,npts] uvs_targ);
    targinfo.patch_id = patch_id;
    targinfo.uvs_targ = uvs_targ;

    ff = 'rsc';

    nptsp1 = npts+1;

% Compute quadrature corrections    
    if(~nonsmoothonly)

      if isfield(opts, 'quadrature_correction')
         Q = opts.quadrature_correction;
      else
        opts_quad = [];
        opts_quad.format = 'rsc';
        opts_quad.rep = 'rpcomb-bc';
%
%  For now Q is going to be a struct with 'quad_format', 
%  'nkernels', 'pde', 'bc', 'kernel', 'ker_order',
%  and either, 'wnear', 'row_ind', 'col_ptr', or
%  with 'spmat' as a sparse matrix or a cell array of wnear/spmat
%  if nkernel is >1
%

        [Q] = helm3d.impedance.get_quadrature_correction(S,eps,zk,alpha,targinfo,opts_quad);
      end
    else
      opts_qcorr = [];
      opts_qcorr.type = 'complex';
      opts_qcorr.nker = 6;
      Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
    end
    nnz = length(Q.col_ind);
    nquad = Q.iquad(end)-1;
    nnzp1 = nnz+1; 

    [novers] = get_oversampling_parameters(S,Q,eps);
    Sover = oversample(S,novers);


% Extract oversampled arrays

    [srcover,~,~,ixyzso,~,wover] = extract_arrays(Sover);
    nptso = Sover.npts; 

% Extract quadrature arrays
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    iquad = Q.iquad;
    wnear = Q.wnear;


    sigma = complex(zeros(1,npts));
    siksigma = complex(zeros(1,npts));
    niter = 0;
    errs = zeros(maxit+1,1);
    maxitp1 = maxit + 1;
    rres = 0;
    nker = 6;

    zpars = complex(zeros(2,1));
    zpars(1) = zk;
    zpars(2) = alpha;

    nlen = length(zlams);
    if nlen == 1
      zlams_use = complex(zlams);
    elseif nlen == npts
      zlams_use = reshape(zlams, [npts,1]);
    else
      error('HELM3D.IMPEDANCE.SOLVER: Invalid size of zlams');
    end


% Call the layer potential evaluator
    # FORTRAN helm_rpcomb_imp_solver_guru(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, double[1] eps, dcomplex[2] zpars, dcomplex[npts] zlams_use, int[1] maxit, int[1] ifout, dcomplex[npts] rhs, int[1] nnz, int[nptsp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, int[1] nquad, int[1] nker, dcomplex[nker,nquad] wnear, int[npatches] novers, int[1] nptso, int[npatp1] ixyzso, double[12,nptso] srcover, double[nptso] wover, double[1] eps_gmres, inout int[1] niter, inout double[maxitp1] errs, inout double[1] rres, inout dcomplex[npts] sigma, inout dcomplex[npts] siksigma);  
    
    densities = complex(zeros(2,npts));
    densities(1,:) = sigma;
    densities(2,:) = siksigma;
    errs = errs(1:niter);
    varargout{1} = errs;
    varargout{2} = rres;
    varargout{3} = Q;
end    
%
%
%-------------------------------------------------
%
%%
%%   Stokes routines
%
%
%-------------------------------------------------

@ +stok3d/+velocity/eval.m 
function p = eval(S,sigma,targinfo,eps,dpars,varargin)
%
%  stok3d.eval
%    Evaluates the stokes layer potential at a collection 
%    of targets
%
%  Syntax
%   pot = stok3d.velocity.eval(S,sigma,targinfo,eps,dpars)
%   pot = stok3d.velocity.eval(S,sigma,targinfo,eps,dpars,opts)
%
%  Integral representation
%     pot = \alpha S_{stok} [\sigma] + \beta D_{stok} [\sigma]
%
%  S_{stok}, D_{stok}: stokes single and double layer potential
%  
%  \alpha, beta = dpars(1:2)
%
%  Note: for targets on surface, only principal value part of the
%    layer potential is returned
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * sigma: (3, ns) layer potential density
%    * targinfo: target info 
%       targinfo.r = (3,nt) target locations
%       targinfo.patch_id (nt,) patch id of target, = -1, if target
%          is off-surface (optional)
%       targinfo.uvs_targ (2,nt) local uv ccordinates of target on
%          patch if on-surface (optional)
%    * eps: precision requested
%    * dpars: kernel parameters
%        dpars(1) - single layer strength
%        dpars(2) - double layer strength
%    * opts: options struct
%        opts.nonsmoothonly - use smooth quadrature rule for evaluating
%           layer potential (false)
%        opts.precomp_quadrature: precomputed quadrature corrections struct 
%           currently only supports quadrature corrections
%           computed in rsc format 
%    

    if(nargin < 6) 
      opts = [];
    else
      opts = varargin{1};
    end

    isprecompq = false;
    if isfield(opts, 'precomp_quadrature')
      Q = opts.precomp_quadrature;
      isprecompq = true;
    end

    nonsmoothonly = false;
    if(isfield(opts,'nonsmoothonly'))
      nonsmoothonly = opts.nonsmoothonly;
    end
    
    if(isprecompq)
      if ~(strcmpi(Q.format,'rsc'))
        fprintf('Invalid precomputed quadrature format\n');
        fprintf('Ignoring quadrature corrections\n');
        opts_qcorr = [];
        opts_qcorr.type = 'double';
        Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
      end
    end


% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    ff = 'rsc';

    [targs] = extract_targ_array(targinfo);
    [ndtarg,ntarg] = size(targs);
    ntargp1 = ntarg+1;

% Compute quadrature corrections   
    if ~isprecompq
      if ~nonsmoothonly
        opts_quad = [];
        opts_quad.format = 'rsc';
%
%  For now Q is going to be a struct with 'quad_format', 
%  'nkernels', 'pde', 'bc', 'kernel', 'ker_order',
%  and either, 'wnear', 'row_ind', 'col_ptr', or
%  with 'spmat' as a sparse matrix or a cell array of wnear/spmat
%  if nkernel is >1
%

        [Q] = stok3d.velocity.get_quadrature_correction(S,eps,dpars,targinfo,opts_quad);
      else
        opts_qcorr = [];
        opts_qcorr.type = 'double';
        Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
      end
    end
    nquad = Q.iquad(end)-1;
    nnz = length(Q.col_ind);
    nnzp1 = nnz+1; 

    [novers] = get_oversampling_parameters(S,Q,eps);
    Sover = oversample(S,novers);


% Extract oversampled arrays

    [srcover,~,~,ixyzso,~,wover] = extract_arrays(Sover);
    nptso = Sover.npts; 

% Extract quadrature arrays
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    iquad = Q.iquad;
    wnear = Q.wnear;

    p = zeros(3,ntarg);

    ndd = 2;
    ndz = 0;
    zpars = [];
    ndi = 0;
    ipars = [];
    nker = 6;
    lwork = 0;
    work = [];
    ndim_s = 3;
    idensflag = 0;
    ipotflag = 0;
    ndim_p = 3;
% Call the layer potential evaluator
    # FORTRAN stok_comb_vel_eval_addsub(int[1] npatches,int[npatches] norders, int[npatp1] ixyzs,int[npatches] iptype, int[1] npts,double[n9,npts] srccoefs,double[n12,npts] srcvals,int[1] ndtarg, int[1] ntarg, double[ndtarg,ntarg] targs, double[1] eps,int[1] ndd, double[ndd] dpars, int[1] ndz, dcomplex[ndz] zpars, int[1] ndi, int[ndi] ipars, int[1] nnz, int[ntargp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, int[1] nquad,int[1] nker, double[nker,nquad] wnear,  int[npatches] novers, int[1] nptso, int[npatp1] ixyzso,double[12,nptso] srcover, double[nptso] wover, int[1] lwork, double[lwork] work, int[1] idensflag, int[1] ndim_s, double[ndim_s,npts] sigma, int[1] ipotflag, int[1] ndim_p, inout double[ndim_p,ntarg] p);   
end    
%
%
%
%----------------------------------
%
@ +stok3d/+velocity/get_quadrature_correction.m 
function Q = get_quadrature_correction(S, eps, dpars, targinfo, opts)
%
%  stok3d.get_quadrature_correction
%    This subroutine returns the near quadrature correction
%    for the combined field representation with density supported
%    on the surface S, and targets given by targinfo 
%    as a sparse matrix/rsc format 
%
%  Syntax
%   Q = stok3d.velocity.get_quadrature_correction(S,eps,dpars)
%   Q = stok3d.velocity.get_quadrature_correction(S,eps,dpars,targinfo)
%   Q = stok3d.velocity.get_quadrature_correction(S,eps,dpars,targinfo,opts)
%
%  Integral representation
%     pot = \alpha S_{stok} [\sigma] + \beta D_{stok} [\sigma]
%
%  S_{stok}, D_{stok}: stokes single and double layer potential
%  
%  \alpha, beta = dpars(1:2)
%
%  Note: for targets on surface, only principal value part of the
%    layer potential is returned
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * eps: precision requested
%    * dpars: kernel parameters
%        dpars(1) - single layer strength
%        dpars(2) - double layer strength
%    * targinfo: target info (optional)
%       targinfo.r = (3,nt) target locations
%       targinfo.du = u tangential derivative info
%       targinfo.dv = v tangential derivative info
%       targinfo.n = normal info
%       targinfo.patch_id (nt,) patch id of target, = -1, if target
%          is off-surface (optional)
%       targinfo.uvs_targ (2,nt) local uv ccordinates of target on
%          patch if on-surface (optional)
%    * opts: options struct
%        opts.format - Storage format for sparse matrices
%           'rsc' - row sparse compressed format
%           'csc' - column sparse compressed format
%           'sparse' - sparse matrix format
%        opts.quadtype - quadrature type, currently only 'ggq' supported
%

    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;
    npp1 = npatches+1;
    n3 = 3;


    if nargin < 4
      targinfo = [];
      targinfo.r = S.r;
      targinfo.du = S.du;
      targinfo.dv = S.dv;
      targinfo.n = S.n;
      targinfo.patch_id = S.patch_id;
      targinfo.uvs_targ = S.uvs_targ;
      opts = [];
    end

    if nargin < 5
      opts = [];

    end

    ff = 'rsc';
    if(isfield(opts,'format'))
       ff = opts.format;
    end

    if(~(strcmpi(ff,'rsc') || strcmpi(ff,'csc') || strcmpi(ff,'sparse')))
       fprintf('invalid quadrature format, reverting to rsc format\n');
       ff = 'rsc';
    end


    targs = extract_targ_array(targinfo); 
    [ndtarg,ntarg] = size(targs);
    ntargp1 = ntarg+1;
    
    if(isfield(targinfo,'patch_id') || isprop(targinfo,'patch_id'))
      patch_id = targinfo.patch_id;
    else
      patch_id = zeros(ntarg,1);
    end

    if(isfield(targinfo,'uvs_targ') || isprop(targinfo,'uvs_targ'))
      uvs_targ = targinfo.uvs_targ;
    else
      uvs_targ = zeros(2,ntarg);
    end

    if(length(patch_id)~=ntarg)
      fprintf('Incorrect size of patch id in target info struct. Aborting! \n');
    end

    [n1,n2] = size(uvs_targ);
    if(n1 ~=2 && n2 ~=ntarg)
      fprintf('Incorrect size of uvs_targ array in targinfo struct. Aborting! \n');
    end


    
    iptype0 = iptype(1);
    norder0 = norders(1);
    rfac = 0.0;
    rfac0 = 0.0;
    # FORTRAN get_rfacs(int[1] norder0, int[1] iptype0, inout double[1] rfac, inout double[1] rfac0);
    

    cms = zeros(3,npatches);
    rads = zeros(npatches,1);
    # FORTRAN get_centroid_rads(int[1] npatches,int[npatches] norders,int[npp1] ixyzs,int[npatches] iptype,int[1] npts,double[n9,npts] srccoefs,inout double[n3,npatches] cms,inout double[npatches] rads);

    rad_near = rads*rfac;
    nnz = 0;
    # FORTRAN findnearmem(double[n3,npatches] cms,int[1] npatches,double[npatches] rad_near,int[1] ndtarg,double [ndtarg,ntarg] targs,int[1] ntarg,inout int[1] nnz);

    row_ptr = zeros(ntarg+1,1);
    col_ind = zeros(nnz,1);
    ntp1 = ntarg+1;
    nnzp1 = nnz+1;
    # FORTRAN findnear(double[n3,npatches] cms,int[1] npatches,double[npatches] rad_near,int[1] ndtarg,double [ndtarg,ntarg] targs, int[1] ntarg,inout int[ntp1] row_ptr,inout int[nnz] col_ind); 

    iquad = zeros(nnz+1,1);
    # FORTRAN get_iquad_rsc(int[1] npatches,int[npp1] ixyzs,int[1] npts,int[1] nnz,int[ntp1] row_ptr,int[nnz] col_ind,inout int[nnzp1] iquad);

    nquad = iquad(nnz+1)-1;
    nker = 6;
    wnear = zeros(nker,nquad);
    iquadtype = 1;
    if(isfield(opts,'quadtype'))
      if(strcmpi(opts.quadtype,'ggq'))
         iquadtype = 1;
      else
        fprintf('Unsupported quadrature type, reverting to ggq\n');
        iquadtype = 1;
      end
    end
    # FORTRAN getnearquad_stok_comb_vel_eval(int[1] npatches,int[npatches] norders,int[npp1] ixyzs,int[npatches] iptype,int[1] npts,double[n9,npts] srccoefs,double[n12,npts] srcvals,int[1] ndtarg,int[1] ntarg,double[ndtarg,ntarg] targs, int[ntarg] patch_id, double[2,ntarg] uvs_targ,double[1] eps,double[2] dpars,int[1] iquadtype,int[1] nnz,int[ntp1] row_ptr,int[nnz] col_ind,int[nnzp1] iquad,double[1] rfac0,int[1] nquad,inout double[nker, nquad] wnear);
    
    Q = [];
    Q.targinfo = targinfo;
    Q.ifcomplex = 0;
    Q.wavenumber = 0;
    Q.kernel_order = -1;
    Q.rfac = rfac;
    Q.nquad = nquad;
    Q.format = ff;
    

    if(abs(dpars(2)) > 1e-16)
        Q.kernel_order = 0;
    end

    if(strcmpi(ff,'rsc'))
        Q.iquad = iquad;
        Q.wnear = wnear;
        Q.row_ptr = row_ptr;
        Q.col_ind = col_ind;
    elseif(strcmpi(ff,'csc'))
        col_ptr = zeros(npatches+1,1);
        row_ind = zeros(nnz,1);
        iper = zeros(nnz,1);
        npatp1 = npatches+1;
        # FORTRAN rsc_to_csc(int[1] npatches, int[1] ntarg, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, inout int[npatp1] col_ptr, inout int[nnz] row_ind, inout int[nnz] iper); 
        Q.iquad = iquad;
        Q.iper = iper;
        Q.wnear = wnear;
        Q.col_ptr = col_ptr;
        Q.row_ind = row_ind;
    else
        spmat = conv_rsc_to_spmat(S,row_ptr,col_ind,wnear);
        Q.spmat = spmat;
    end
    
end
%
%
%
%
%-------------------------------------------------

@ +stok3d/+velocity/solver.m 
function [sigma,varargout] = solver(S, rhs, eps, dpars, opts)
%
%  stok3d.solver
%    Solve the Stokes boundary value problem
%
%  Syntax
%   sigma = stok3d.velocity.solver(S,sigma,eps,dpars)
%   sigma = stok3d.velocity.solver(S,sigma,eps,dpars,opts)
%
%  Integral representation
%     pot = \alpha S_{stok} [\sigma] + \beta D_{stok} [\sigma]
%
%  S_{stok}, D_{stok}: Stokes single and double layer potential
%  
%  \alpha, beta = dpars(1:2)
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * rhs: (3, npts) boundary data 
%    * eps: precision requested
%    * dpars: kernel parameters
%        dpars(1) - single layer strength
%        dpars(2) - double layer strength
%    * opts: options struct
%        opts.nonsmoothonly - use smooth quadrature rule for evaluating
%           layer potential (false)
%        opts.eps_gmres - tolerance to which linear system is to be
%           solved (eps_gmres = eps)
%        opts.maxit - maximum number of gmres iterations (200)
%        opts.ifout - whether to solve interior problem or not (1)
%        opts.quadrature_correction - precomputed quadrature correction ([])
%        
%
%  Output arguemnts:
%    * sigma: (3,npts) layer potential density
%    
%
    
    if(nargin < 5) 
      opts = [];
    end

    nonsmoothonly = false;
    if(isfield(opts,'nonsmoothonly'))
      nonsmoothonly = opts.nonsmoothonly;
    end

    eps_gmres = eps;
    if(isfield(opts,'eps_gmres'))
      eps_gmres = opts.eps_gmres;
    end

    maxit = 200;
    if(isfield(opts,'maxit'))
      maxit = opts.maxit;
    end

    ifout = 1;
    if(isfield(opts,'ifout'))
      ifout = opts.ifout;
    end

% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    targinfo = [];
    targinfo.r = S.r;
    targinfo.du = S.du;
    targinfo.dv = S.dv;
    targinfo.n = S.n;
    patch_id  = zeros(npts,1);
    uvs_targ = zeros(2,npts);
    # FORTRAN get_patch_id_uvs(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, inout int[npts] patch_id, inout double[2,npts] uvs_targ);
    targinfo.patch_id = patch_id;
    targinfo.uvs_targ = uvs_targ;

    ff = 'rsc';

    nptsp1 = npts+1;

% Compute quadrature corrections    
    if(~nonsmoothonly)

      if isfield(opts, 'quadrature_correction')
         Q = opts.quadrature_correction;
      else
        opts_quad = [];
        opts_quad.format = 'rsc';
%
%  For now Q is going to be a struct with 'quad_format', 
%  'nkernels', 'pde', 'bc', 'kernel', 'ker_order',
%  and either, 'wnear', 'row_ind', 'col_ptr', or
%  with 'spmat' as a sparse matrix or a cell array of wnear/spmat
%  if nkernel is >1
%

        [Q] = stok3d.velocity.get_quadrature_correction(S,eps,dpars,targinfo,opts_quad);
      end
    else
      opts_qcorr = [];
      opts_qcorr.type = 'double';
      Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
    end
    nnz = length(Q.col_ind);
    nquad = Q.iquad(end)-1;
    nnzp1 = nnz+1; 

    [novers] = get_oversampling_parameters(S,Q,eps);
    Sover = oversample(S,novers);


% Extract oversampled arrays

    [srcover,~,~,ixyzso,~,wover] = extract_arrays(Sover);
    nptso = Sover.npts; 

% Extract quadrature arrays
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    iquad = Q.iquad;
    wnear = Q.wnear;


    sigma = zeros(3,npts);
    niter = 0;
    errs = zeros(maxit+1,1);
    maxitp1 = maxit + 1;
    rres = 0;
    nker = 6;
% Call the layer potential evaluator
    # FORTRAN stok_comb_vel_solver_guru(int[1] npatches,int[npatches] norders, int[npatp1] ixyzs,int[npatches] iptype, int[1] npts,double[n9,npts] srccoefs,double[n12,npts] srcvals, double[1] eps, double[2] dpars, int[1] maxit, int[1] ifout, double[3,npts] rhs, int[1] nnz, int[nptsp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, int[1] nquad, int[1] nker, double[nker,nquad] wnear, int[npatches] novers, int[1] nptso, int[npatp1] ixyzso, double[12,nptso] srcover, double[nptso] wover, double[1] eps_gmres, inout int[1] niter, inout double[maxitp1] errs, inout double[1] rres, inout double[3,npts] sigma);  

    errs = errs(1:niter);
    varargout{1} = errs;
    varargout{2} = rres;
    varargout{3} = Q;
end  
%
%
%
%
%----------------------------------------
%%
%%   Maxwell pec routines
%
%
%-------------------------------------------------

@ +em3d/+pec/eval.m 
function [E, H] = eval(S, densities, targinfo, eps, zk, rep_params, varargin)
%
%  em3d.pec.eval
%
%    This subroutine evaluates the electric and magnetic
%    field at a colelction of targets given the solution
%    to the corresponding integral equation
%
%
%  Notes for this routine:
%  The PDE takes the form
%  1v) \nabla \times E =  ik H
%  2v) \nabla \cdot  E =     0
%  3v) \nabla \times H = -ik E
%  4v) \nabla \cdot  H =     0
%  
%  where E is the electric field, H is the magnetic field, 
%  and k is the wavenumber
%
%  The PEC boundary conditions are given by
%  1b) n \times (E + E_in) = 0
%  2b) n \cdot  (E + E_in) = \rho
%  3b) n \times (H + H_in) = J
%  4b) n \cdot  (H + H_in) = 0
%
%  where (E_in, H_in) are the incoming electric and magnetic 
%  fields, \rho is the surface current, and J is the 
%  surface current.
% 
%  This routine will support the following representations:
%  * nrccie   (Non-resonant charge current integral equation)
%  * dpie     (Decoupled potential integral equation)
%  * mfie     (Magnetic field integral equation)
%  * aumfie   (Augmented magnetic field integral equation)
%  * aurcsie  (Augmented regularized combined source integral equation)
%  * gendeb   (Generalized Debye)
%
%  For notes on the specific representations, boundary integral equations,
%  and order of kernels returned by this routine, checkout
%  em3d.pec.Contents.m
%
%  Syntax
%   [E, H] = em3d.pec.eval(S, densities, targinfo, eps, zk, rep_params)
%   [E, H] = em3d.pec.eval(S, densities, targinfo, eps, zk, rep_params, opts)
%
%  Note: for targets on surface, only principal value part of the
%    layer potential is returned
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * densities: layer potential densities, of size (ndim, npts)
%        where ndim depends on the integral representation used
%    * targinfo: target info 
%       targinfo.r = (3,nt) target locations
%       targinfo.patch_id (nt,) patch id of target, = -1, if target
%          is off-surface (optional)
%       targinfo.uvs_targ (2,nt) local uv ccordinates of target on
%          patch if on-surface (optional)
%    * eps: precision requested
%    * zk : wave number
%    * rep_params: parameters for integral representation 
%                  for nrccie, it should be a scalar
%    * opts: options struct
%        opts.rep - integral representation being used
%                         Supported representations
%                         'nrccie'
%        opts.nonsmoothonly - use smooth quadrature rule for
%                             evaluating layer potential (false)
%        opts.precomp_quadrature: precomputed quadrature corrections struct 
%           currently only supports quadrature corrections
%           computed in rsc format 
%
%
%
%

    if(nargin < 7) 
      opts = [];
    else
      opts = varargin{1};
    end

    nonsmoothonly = false;
    if(isfield(opts,'nonsmoothonly'))
      nonsmoothonly = opts.nonsmoothonly;
    end

    isprecompq = false;
    if isfield(opts, 'precomp_quadrature')
      Q = opts.precomp_quadrature;
      isprecompq = true;
    end

    if(isprecompq)
      if ~(strcmpi(Q.format,'rsc'))
        fprintf('Invalid precomputed quadrature format\n');
        fprintf('Ignoring quadrature corrections\n');
        opts_qcorr = [];
        opts_qcorr.type = 'complex';

        opts_qcorr.nker = nker;
        Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
      end
    end

    
    rep = 'nrccie';

    if isfield(opts, 'rep')
      rep = opts.rep;
    end

    if strcmpi(rep, 'nrccie')
      nker = 4;
      ndim_s = 4;
      [nn, ~] = size(densities);
      zpars = complex(zeros(2,1));
      zpars(1) = zk;
      zpars(2) = rep_params;
      
      if nn ~= ndim_s
        error('EM3D.PEC.EVAL: number of densities not consistent with representation\n'); 
      end
    end


% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    ff = 'rsc';

    [targs] = extract_targ_array(targinfo);
    [ndtarg,ntarg] = size(targs);
    ntargp1 = ntarg+1;

% Compute quadrature corrections   
    if ~isprecompq
      if ~nonsmoothonly
        opts_quad = [];
        opts_quad.format = 'rsc';
        opts_quad.rep = [rep '-eval'];
%
%  For now Q is going to be a struct with 'quad_format', 
%  'nkernels', 'pde', 'bc', 'kernel', 'ker_order',
%  and either, 'wnear', 'row_ind', 'col_ptr', or
%  with 'spmat' as a sparse matrix or a cell array of wnear/spmat
%  if nkernel is >1
%

        [Q] = em3d.pec.get_quadrature_correction(S, eps, zk, rep_params, targinfo, opts_quad);
      else
        opts_qcorr = [];
        opts_qcorr.type = 'complex';
        opts_qcorr.nker = nker;
        Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
      end
    end
    nquad = Q.iquad(end)-1;
    nnz = length(Q.col_ind);
    nnzp1 = nnz+1; 

    [novers] = get_oversampling_parameters(S, Q, eps);
    Sover = oversample(S,novers);


% Extract oversampled arrays

    [srcover,~,~,ixyzso,~,wover] = extract_arrays(Sover);
    nptso = Sover.npts; 

% Extract quadrature arrays
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    iquad = Q.iquad;
    wnear = Q.wnear;

    p = complex(zeros(6,ntarg));

    ipotflag = 3;


    ndd = 0;
    dpars = [];
    ndz = length(zpars);
    ndi = 0;
    ipars = [];
    lwork = 0;
    work = [];
    ndim_p = 6;
    idensflag = 1;
% Call the layer potential evaluator
    
    if strcmpi(rep, 'nrccie')
      # FORTRAN em_nrccie_eval_addsub(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, int[1] ndtarg, int[1] ntarg, double[ndtarg,ntarg] targs, double[1] eps, int[1] ndd, double[ndd] dpars, int[1] ndz, dcomplex[ndz] zpars, int[1] ndi, int[ndi] ipars, int[1] nnz, int[ntargp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, int[1] nquad, int[1] nker, dcomplex[nker,nquad] wnear,  int[npatches] novers, int[1] nptso, int[npatp1] ixyzso, double[12,nptso] srcover, double[nptso] wover, int[1] lwork, double[lwork] work, int[1] idensflag, int[1] ndim_s, dcomplex[ndim_s,npts] densities, int[1] ipotflag, int[1] ndim_p, inout dcomplex[ndim_p,ntarg] p);   
    end
    E = p(1:3,:);
    H = p(4:6,:);
end    
%
%
%
%----------------------------------
%
@ +em3d/+pec/get_quadrature_correction.m 
function Q = get_quadrature_correction(S, eps, zk, rep_params, targinfo, opts)
%
%  em3d.pec.get_quadrature_correction
%    This subroutine returns the near quadrature correction
%    for the chosen maxwell representation, with densities supported
%    on the surface, and targets given by targinfo 
%    as a cell array of sparse matrices or an array of matrices
%    in the rsc format, where each folumn of the matrix is the
%    representation of the sparse matrix corresponding to one
%    of the kernels
%
%  Syntax
%   Q = em3d.pec.get_quadrature_correction(S,eps,zk)
%   Q = em3d.pec.get_quadrature_correction(S,eps,zk,rep_params,targinfo)
%   Q = em3d.pec.get_quadrature_correction(S,eps,zk,rep_params,targinfo,opts)
%
%  This routine will support the following representations:
%  * nrccie   (Non-resonant charge current integral equation)
%  * dpie     (Decoupled potential integral equation)
%  * mfie     (Magnetic field integral equation)
%  * aumfie   (Augmented magnetic field integral equation)
%  * aurcsie  (Augmented regularized combined source integral equation)
%  * gendeb   (Generalized Debye)
%
%  For notes on the specific representations, boundary integral equations,
%  and order of kernels returned by this routine, checkout
%  em3d.pec.Contents.m
%
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * eps: precision requested
%    * zk: wave number
%    * rep_params: parameters for integral representation 
%                  for nrccie, it should be a scalar
%    * targinfo: target info (optional)
%       targinfo.r = (3,nt) target locations
%       targinfo.du = u tangential derivative info
%       targinfo.dv = v tangential derivative info
%       targinfo.n = normal info
%       targinfo.patch_id (nt,) patch id of target, = -1, if target
%          is off-surface (optional)
%       targinfo.uvs_targ (2,nt) local uv ccordinates of target on
%          patch if on-surface (optional)
%    * opts: options struct
%        opts.format - Storage format for sparse matrices
%           'rsc' - row sparse compressed format
%           'csc' - column sparse compressed format
%           'sparse' - sparse matrix format
%        opts.quadtype - quadrature type, currently only 'ggq' supported
%        opts.rep - integral representation being used
%                         Supported representations
%                         'nrccie-bc', 'nrccie-eval'.
%                         If option is <rep>-bc, then targinfo is ignored
%

    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;
    npp1 = npatches+1;
    nsp1 = npts + 1;
    n3 = 3;

    if nargin < 5
      targinfo = [];
      targinfo.r = S.r;
      targinfo.du = S.du;
      targinfo.dv = S.dv;
      targinfo.n = S.n;
      targinfo.patch_id = S.patch_id;
      targinfo.uvs_targ = S.uvs_targ;
      opts = [];
    end

    qtype = 'nrccie-bc';

    if nargin < 6
      opts = [];
    end

    if isfield(opts, 'rep')
      qtype = opts.rep;
    end

    ff = 'rsc';
    if(isfield(opts,'format'))
       ff = opts.format;
    end

    if(~(strcmpi(ff,'rsc') || strcmpi(ff,'csc') || strcmpi(ff,'sparse')))
       fprintf('invalid quadrature format, reverting to rsc format\n');
       ff = 'rsc';
    end

    tinfouse = [];
    if strcmpi(qtype, 'nrccie-bc')
      tinfouse.r = S.r;
      tinfouse.du = S.du;
      tinfouse.dv = S.dv;
      tinfouse.n = S.n;
      tinfouse.patch_id = S.patch_id;
      tinfouse.uvs_targ = S.uvs_targ;
    else
      tinfouse = targinfo;
    end




    targs = extract_targ_array(tinfouse); 
    [ndtarg,ntarg] = size(targs);
    ntargp1 = ntarg+1;
    
    if(isfield(tinfouse,'patch_id') || isprop(tinfouse,'patch_id'))
      patch_id = tinfouse.patch_id;
    else
      patch_id = zeros(ntarg,1);
    end

    if(isfield(tinfouse,'uvs_targ') || isprop(tinfouse,'uvs_targ'))
      uvs_targ = tinfouse.uvs_targ;
    else
      uvs_targ = zeros(2,ntarg);
    end

    if(length(patch_id)~=ntarg)
      fprintf('Incorrect size of patch id in target info struct. Aborting! \n');
    end

    [n1,n2] = size(uvs_targ);
    if(n1 ~=2 && n2 ~=ntarg)
      fprintf('Incorrect size of uvs_targ array in targinfo struct. Aborting! \n');
    end


    
    iptype0 = iptype(1);
    norder0 = norders(1);
    rfac = 0.0;
    rfac0 = 0.0;
    # FORTRAN get_rfacs(int[1] norder0, int[1] iptype0, inout double[1] rfac, inout double[1] rfac0);
    

    cms = zeros(3,npatches);
    rads = zeros(npatches,1);
    # FORTRAN get_centroid_rads(int[1] npatches,int[npatches] norders,int[npp1] ixyzs,int[npatches] iptype,int[1] npts,double[n9,npts] srccoefs,inout double[n3,npatches] cms,inout double[npatches] rads);

    rad_near = rads*rfac;
    nnz = 0;
    # FORTRAN findnearmem(double[n3,npatches] cms,int[1] npatches,double[npatches] rad_near,int[1] ndtarg,double [ndtarg,ntarg] targs,int[1] ntarg,inout int[1] nnz);

    row_ptr = zeros(ntarg+1,1);
    col_ind = zeros(nnz,1);
    ntp1 = ntarg+1;
    nnzp1 = nnz+1;
    # FORTRAN findnear(double[n3,npatches] cms,int[1] npatches,double[npatches] rad_near,int[1] ndtarg,double [ndtarg,ntarg] targs, int[1] ntarg,inout int[ntp1] row_ptr,inout int[nnz] col_ind); 

    iquad = zeros(nnz+1,1);
    # FORTRAN get_iquad_rsc(int[1] npatches,int[npp1] ixyzs,int[1] npts,int[1] nnz,int[ntp1] row_ptr,int[nnz] col_ind,inout int[nnzp1] iquad);

    nquad = iquad(nnz+1)-1;
    iquadtype = 1;
    if(isfield(opts,'quadtype'))
      if(strcmpi(opts.quadtype,'ggq'))
         iquadtype = 1;
      else
        fprintf('Unsupported quadrature type, reverting to ggq\n');
        iquadtype = 1;
      end
    end

    if strcmpi(qtype, 'nrccie-bc')
      nker = 9;
      wnear = complex(zeros(nker,nquad));
      ndz = 2;
      zpars = complex(zeros(2,1));
      zpars(1) = zk;
      zpars(2) = rep_params;

      # FORTRAN getnearquad_em_nrccie_pec(int[1] npatches, int[npatches] norders, int[npp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, double[1] eps, dcomplex[2] zpars, int[1] iquadtype, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, double[1] rfac0,int[1] nquad, inout dcomplex[nker,nquad] wnear);
    elseif strcmpi(qtype, 'nrccie-eval')
      nker = 4;
      wnear = complex(zeros(nker,nquad));
      zpuse = complex(zk);
      # FORTRAN getnearquad_em_nrccie_pec_eval(int[1] npatches, int[npatches] norders, int[npp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, int[1] ndtarg, int[1] ntarg, double[ndtarg,ntarg] targs, int[ntarg] patch_id, double[2,ntarg] uvs_targ, double[1] eps, dcomplex[1] zpuse, int[1] iquadtype, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, double[1] rfac0, int[1] nquad, inout dcomplex[nker,nquad] wnear);
    else
      error('em3d.pec.GET_QUADRATURE_CORRECTION:Unsupported quadrature correction');
    end
    
    Q = [];
    Q.targinfo = targinfo;
    Q.ifcomplex = 1;
    Q.wavenumber = zk;
    Q.kernel_order = -1;
    Q.rfac = rfac;
    Q.nquad = nquad;
    Q.format = ff;
    Q.kernel_order = 0;

    if(strcmpi(ff,'rsc'))
        Q.iquad = iquad;
        Q.wnear = wnear;
        Q.row_ptr = row_ptr;
        Q.col_ind = col_ind;
    elseif(strcmpi(ff,'csc'))
        col_ptr = zeros(npatches+1,1);
        row_ind = zeros(nnz,1);
        iper = zeros(nnz,1);
        npatp1 = npatches+1;
        # FORTRAN rsc_to_csc(int[1] npatches, int[1] ntarg, int[1] nnz, int[ntp1] row_ptr, int[nnz] col_ind, inout int[npatp1] col_ptr, inout int[nnz] row_ind, inout int[nnz] iper); 
        Q.iquad = iquad;
        Q.iper = iper;
        Q.wnear = wnear;
        Q.col_ptr = col_ptr;
        Q.row_ind = row_ind;
    else
        spmat = conv_rsc_to_spmat(S,row_ptr,col_ind,wnear);
        Q.spmat = spmat;
    end
    
end
%
%
%
%
%-------------------------------------------------

@ +em3d/+pec/solver.m 
function [densities, varargout] = solver(S, einc, hinc, eps, zk, rep_params, opts)
%
%  em3d.pec.solver
%    Solve the Maxwell pec boundary value problem
%
%  Syntax
%   [densities] = em3d.pec.solver(S, einc, hinc, eps, zk, rep_params)
%   [densities] = em3d.pec.solver(S, einc, hinc, eps, zk, rep_params, opts)
%
%  This routine will support the following representations:
%  * nrccie   (Non-resonant charge current integral equation)
%  * dpie     (Decoupled potential integral equation)
%  * mfie     (Magnetic field integral equation)
%  * aumfie   (Augmented magnetic field integral equation)
%  * aurcsie  (Augmented regularized combined source integral equation)
%  * gendeb   (Generalized Debye)
%
%  For notes on the specific representations, boundary integral equations,
%  and order of kernels returned by this routine, checkout
%  em3d.pec.Contents.m
%
%  Input arguments:
%    * S: surfer object, see README.md in matlab for details
%    * einc, hinc: incident electric and magnetic fields 
%    * eps: precision requested
%    * zk: wave number
%    * rep_params: parameters for integral representation 
%                  for nrccie, it should be a scalar
%    * opts: options struct
%        opts.nonsmoothonly - use smooth quadrature rule for evaluating
%           layer potential (false)
%        opts.eps_gmres - tolerance to which linear system is to be
%           solved (eps_gmres = eps)
%        opts.maxit - maximum number of gmres iterations (200)
%        opts.quadrature_correction - precomputed quadrature correction ([])
%        opts.rep - integral representation being used
%                         Supported representations
%
%  Output arguemnts:
%    * densities: layer potential density
%    
%
    
    if(nargin < 7) 
      opts = [];
    end

    nonsmoothonly = false;
    if(isfield(opts,'nonsmoothonly'))
      nonsmoothonly = opts.nonsmoothonly;
    end

    rep = 'nrccie';
    if isfield(opts, 'rep')
      rep = opts.rep;
    end

    if strcmpi(rep, 'nrccie')
      nker = 9;
    end

    eps_gmres = eps;
    if(isfield(opts,'eps_gmres'))
      eps_gmres = opts.eps_gmres;
    end

    maxit = 200;
    if(isfield(opts,'maxit'))
      maxit = opts.maxit;
    end


% Extract arrays
    [srcvals,srccoefs,norders,ixyzs,iptype,wts] = extract_arrays(S);
    [n12,npts] = size(srcvals);
    [n9,~] = size(srccoefs);
    [npatches,~] = size(norders);
    npatp1 = npatches+1;

    targinfo = [];
    targinfo.r = S.r;
    targinfo.du = S.du;
    targinfo.dv = S.dv;
    targinfo.n = S.n;
    patch_id  = zeros(npts,1);
    uvs_targ = zeros(2,npts);
    # FORTRAN get_patch_id_uvs(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, inout int[npts] patch_id, inout double[2,npts] uvs_targ);
    targinfo.patch_id = patch_id;
    targinfo.uvs_targ = uvs_targ;

    ff = 'rsc';

    nptsp1 = npts+1;

% Compute quadrature corrections    
    if(~nonsmoothonly)

      if isfield(opts, 'quadrature_correction')
         Q = opts.quadrature_correction;
      else
        opts_quad = [];
        opts_quad.format = 'rsc';
        opts_quad.rep = [rep '-bc'];
%
%  For now Q is going to be a struct with 'quad_format', 
%  'nkernels', 'pde', 'bc', 'kernel', 'ker_order',
%  and either, 'wnear', 'row_ind', 'col_ptr', or
%  with 'spmat' as a sparse matrix or a cell array of wnear/spmat
%  if nkernel is >1
%

        [Q] = em3d.pec.get_quadrature_correction(S,eps,zk,rep_params,targinfo,opts_quad);
      end
    else
      opts_qcorr = [];
      opts_qcorr.type = 'complex';
      opts_qcorr.nker = nker;
      Q = init_empty_quadrature_correction(targinfo,opts_qcorr);
    end
    nnz = length(Q.col_ind);
    nquad = Q.iquad(end)-1;
    nnzp1 = nnz+1; 

    [novers] = get_oversampling_parameters(S,Q,eps);
    Sover = oversample(S,novers);


% Extract oversampled arrays

    [srcover,~,~,ixyzso,~,wover] = extract_arrays(Sover);
    nptso = Sover.npts; 

% Extract quadrature arrays
    row_ptr = Q.row_ptr;
    col_ind = Q.col_ind;
    iquad = Q.iquad;
    wnear = Q.wnear;


    niter = 0;
    errs = zeros(maxit+1,1);
    maxitp1 = maxit + 1;
    rres = 0;

    if strcmpi(rep, 'nrccie')
      zjvec = complex(zeros(3,npts));
      rho = complex(zeros(1,npts));
      zpars = complex(zeros(2,1));
      zpars(1) = zk;
      zpars(2) = rep_params;
% Call the layer potential evaluator
      # FORTRAN em_nrccie_pec_solver_guru(int[1] npatches, int[npatches] norders, int[npatp1] ixyzs, int[npatches] iptype, int[1] npts, double[n9,npts] srccoefs, double[n12,npts] srcvals, double[1] eps, dcomplex[2] zpars, int[1] maxit, dcomplex[3,npts] einc, dcomplex[3,npts] hinc, int[1] nnz, int[nptsp1] row_ptr, int[nnz] col_ind, int[nnzp1] iquad, int[1] nquad, int[1] nker, dcomplex[nker,nquad] wnear, int[npatches] novers, int[1] nptso, int[npatp1] ixyzso, double[12,nptso] srcover, double[nptso] wover, double[1] eps_gmres, inout int[1] niter, inout double[maxitp1] errs, inout double[1] rres, inout dcomplex[3,npts] zjvec, inout dcomplex[npts] rho); 
      
      densities = complex(zeros(4,npts));
      densities(1:3,:) = zjvec;
      densities(4,:) = rho;
    end

    errs = errs(1:niter);
    varargout{1} = errs;
    varargout{2} = rres;
    varargout{3} = Q;
end    
%
%

